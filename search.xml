<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[sass控制指令-循环&条件]]></title>
    <url>%2F2019%2F06%2F03%2FControl-Directives%2F</url>
    <content type="text"><![CDATA[SassScript支持基本控制指令，仅在某些条件下包含样式，或者在变化时多次包含相同的样式。 请注意，控制指令是一项高级功能，不建议在日常样式的过程中使用。它们主要用于mixins，特别是像Compass这样的库的一部分，因此需要很大的灵活性。 @for该@for指令重复输出一组样式。对于每次重复，使用计数器变量来调整输出。该指令有两种形式： @for $var from &lt;start&gt; through &lt;end&gt;和@for $var from &lt;start&gt; to &lt;end&gt;。注意关键字的区别through和to。$var可以是任何变量名称，如$i; &lt;start&gt;并且&lt;end&gt;是应该返回整数的SassScript表达式。 该@for语句设置$var为指定范围内的每个连续数字，并且每次使用该值输出嵌套样式$var。对于具有以下形式from ... through，所述范围包括的值&lt;start&gt;和 &lt;end&gt;，但形式from ... to运行至但不包括的值 &lt;end&gt;。使用through语法， 12345678@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125;@for $i from 1 to 3 &#123; .item-#&#123;$i&#125; &#123; width: $i + em; &#125;&#125; 被编译为： 123456789101112131415.item-1 &#123; width: 2em; &#125;.item-2 &#123; width: 4em; &#125;.item-3 &#123; width: 6em; &#125; .item-1 &#123; width: 1em;&#125;.item-2 &#123; width: 2em;&#125; @each该@each规则的形式@each $var in &lt;list&gt;。 $var可以是任何变量名，例如$length或$name，&lt;list&gt;是一个返回列表的SassScript表达式。 该@each规则集$var列表中的每个项目，然后输出它包含使用该值的风格$var。例如： 12345@each $animal in puma, sea-slug, egret, salamander &#123; .#&#123;$animal&#125;-icon &#123; background-image: url(&apos;/images/#&#123;$animal&#125;.png&apos;); &#125;&#125; 被编译为： 12345678.puma-icon &#123; background-image: url(&apos;/images/puma.png&apos;); &#125;.sea-slug-icon &#123; background-image: url(&apos;/images/sea-slug.png&apos;); &#125;.egret-icon &#123; background-image: url(&apos;/images/egret.png&apos;); &#125;.salamander-icon &#123; background-image: url(&apos;/images/salamander.png&apos;); &#125; @while该@while指令采用SassScript表达式并重复输出嵌套样式，直到语句求值为止false。这可以用来实现比@for语句更复杂的循环，尽管这很少是必要的。例如： 12345$i: 6;@while $i &gt; 0 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125; $i: $i - 2;&#125; 被编译为： 12345678.item-6 &#123; width: 12em; &#125;.item-4 &#123; width: 8em; &#125;.item-2 &#123; width: 4em; &#125; @if该@if指令需要SassScript表达和使用嵌套在它下面的样式，如果表达式返回以外的任何其他false或null： 12345p &#123; @if 1 + 1 == 2 &#123; border: 1px solid; &#125; @if 5 &lt; 3 &#123; border: 2px dotted; &#125; @if null &#123; border: 3px double; &#125;&#125; 被编译为： 12p &#123; border: 1px solid; &#125; 该@if声明后面可以跟几个@else if声明和一个@else声明。如果@if语句失败，@else if则按顺序尝试语句，直到成功或@else到达为止。例如： 123456789101112$type: monster;p &#123; @if $type == ocean &#123; color: blue; &#125; @else if $type == matador &#123; color: red; &#125; @else if $type == monster &#123; color: green; &#125; @else &#123; color: black; &#125;&#125; 被编译为： 12p &#123; color: green; &#125; ###]]></content>
      <categories>
        <category>sass学习手记</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本溢出与 Tooltip，如何更好的处理二者]]></title>
    <url>%2F2019%2F06%2F03%2Fellpise%2F</url>
    <content type="text"><![CDATA[前言前端开发中文本溢出是一个非常常见的场景，如果在编程中没有对这部分进行处理，很可能会出现因为文本太长影响整体视觉效果或前端布局的情况。因此，对于有可能出现文本溢出的地方，我们需要对他们进行一些处理。当然，单纯地处理溢出很简单，如果要结合 Tooltip 做一些略复杂的交互显示，可能需要考虑更多的内容，接下来我们来对这些内容逐步的进行探讨： 实现文本溢出省略的处理方案目前而言，常见的处理方案可能分为以下几种情况，单行省略处理和多行省略，这部分的 CSS 方案在网上很容易能找得到。话不多少，先扔代码： 单行省略 12345div &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 核心的部分是 text-overflow: ellipsis; 但是有几个需要注意的点：这个属性只对那些在块级元素溢出的内容有效，而且必须要与块级元素内联(inline)方向一致，所以我们还需要加上 white-space: nowrap, 并将 overflow 设置为 hidden 以使得 text-overflow 生效。 多行省略 123456div &#123; display: -webkit-box; overflow: hidden; -webkit-line-clamp: 2; -webkit-box-orient: vertical;&#125; 这种方式实现的省略可以在文本超出规定行数时超出的部分按照 ...，当时它也只适用于 webkit 内核的浏览器。非 webkit 内核的实现方案需要用伪元素或 float 的方式来实现，这里我们不做讨论，感兴趣的朋友可以参考这篇博客。 Tooltip 结合 ellipsis关于 tooltip 的实现本文不做探讨，我们采用 Element 中的 Tooltip 作为示例进行演示： 阶段 1首先来进行暴力拼接，将文本的全部内容直接进行 Tooltip 显示而不用管是否会触发超出省略： 123&lt;el-tooltip :content=&quot;content&quot;&gt; &lt;div class=&quot;ellipsis-item&quot;&gt;&#123;&#123; content &#125;&#125;&lt;/div&gt;&lt;/el-tooltip&gt; 实现的内容大概是这个样子的： 但是这显然不是一个很好的解决方案，对于那些并没有溢出的文本，每次 hover 上去时还会显示 Tooltip，实在是一种糟心的体验。因此我们需要对上面的内容进行一些优化。 阶段 2这次我们要实现一个文本溢出时 hover 显示 Tooltip，不溢出时 hover 不显示的效果。但是我们在第一步文本溢出的配置中是用 css 来进行设置的，如何才能通过 JS 来控制什么显示 Tooltip 的时机呢？这就要从文本溢出的原理讲起了： 我们知道，每一个 HTML 元素都具有：clientHeight(clientWidth)、offsetHeight(offsetWidth)、scrollHeight(scrollWidth)、offsetTop(offsetLeft)、scrollTop(scrollLeft) 五种类型的属性，他们分别表示： clientHeight(clientWidth): 对象内容的可视区的高度（宽度）。包括 padding 但不包括 border、水平滚动条、margin 的元素的高度(宽度）。对于 inline 的元素这个属性一直是 0 offsetHeight(offsetWidth): 对象整体的实际高度（宽度）。包括 padding、border、水平滚动条，但不包括 margin 的元素的高度（宽度）。对于inline的元素这个属性一直是 0，单位 px。 scrollHeight(scrollWidth): 对象的实际内容的高度（宽度）。当实际内容超出可视区时会通过出现滚动条，通过滚动条可以调节实际内容在可视区的显示部分。 scrollTop(scrollLeft): 在有滚动条时，滚动条向下（向右）滚动的距离也就是元素顶部（左侧）被遮住部分的高度（宽度）。 offsetTop(offsetLeft): 当前元素顶部（左侧边框）距离最近的定位父元素顶部（左侧边框）的距离。 对于单行省略而言：当文本所在的块元素的实际宽度超过了可视区的宽度（即 scrollWidth 超过了 clientWidth)，那么就会被判定为文本超出，我们就可以看见熟悉的 ... 了。 同样的道理，对于多行省略而言：文本检测超长的方式并不是 inline 的方向，而是垂直方向，所以我们同理变换即可理解，也就是说，党文在所在快元素的实际高度超过了可视区的高度（即 scrollHeight 超过了 clientHeight），那么就会被判定为文本超出。 根据以上部分的原理，我们可以很容易的实现文本超长 hover 时显示 tooltip，而不超长时候不作处理的方法： 12345678&lt;el-tooltip v-if=&quot;showTooltip&quot; :content=&quot;content&quot;&gt; &lt;div ref=&quot;content&quot; class=&quot;ellipsis-item&quot;&gt;&#123;&#123; content &#125;&#125;&lt;/div&gt;&lt;/el-tooltip&gt;&lt;div v-else ref=&quot;content&quot; class=&quot;ellipsis-item&quot;&gt;&#123;&#123; content &#125;&#125;&lt;/div&gt;this.showTooltip = this.$refs.content.offsetWidth &lt; this.$refs.content.scrollWidth || // 处理单行省略 this.$refs.name.offsetHeight &lt; this.$refs.name.scrollHeight; // 处理多行省略 所以一些看似比较复杂的应用场景其实都是基本的原理拼接而成的，我们在了解这些原理之后便可以举一反三玩出很多的花样来。就这么简单~ 参考资料：http://imweb.io/topic/57c5409e808fd2fb204eef52https://www.w3.org/TR/cssom-view]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>ellpise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4类 JavaScript 内存泄漏及如何避免]]></title>
    <url>%2F2019%2F05%2F23%2Fmemory%2F</url>
    <content type="text"><![CDATA[原文：4 Types of Memory Leaks in JavaScript and How to Get Rid Of Them 译者注：本文并没有逐字逐句的翻译，而是把我认为重要的信息做了翻译。如果您的英文熟练，可以直接阅读原文。 本文将探索常见的客户端 JavaScript 内存泄漏，以及如何使用 Chrome 开发工具发现问题。 简介内存泄漏是每个开发者最终都要面对的问题，它是许多问题的根源：反应迟缓，崩溃，高延迟，以及其他应用问题。 什么是内存泄漏？本质上，内存泄漏可以定义为：应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收。编程语言管理内存的方式各不相同。只有开发者最清楚哪些内存不需要了，操作系统可以回收。一些编程语言提供了语言特性，可以帮助开发者做此类事情。另一些则寄希望于开发者对内存是否需要清晰明了。 JavaScript 内存管理JavaScript 是一种垃圾回收语言。垃圾回收语言通过周期性地检查先前分配的内存是否可达，帮助开发者管理内存。换言之，垃圾回收语言减轻了“内存仍可用”及“内存仍可达”的问题。两者的区别是微妙而重要的：仅有开发者了解哪些内存在将来仍会使用，而不可达内存通过算法确定和标记，适时被操作系统回收。 JavaScript 内存泄漏垃圾回收语言的内存泄漏主因是不需要的引用。理解它之前，还需了解垃圾回收语言如何辨别内存的可达与不可达。 Mark-and-sweep大部分垃圾回收语言用的算法称之为 Mark-and-sweep 。算法由以下几步组成： 垃圾回收器创建了一个“roots”列表。Roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）； 所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。 所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。 现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。 不需要的引用是指开发者明知内存引用不再需要，却由于某些原因，它仍被留在激活的 root 树中。在 JavaScript 中，不需要的引用是保留在代码中的变量，它不再需要，却指向一块本该被释放的内存。有些人认为这是开发者的错误。 为了理解 JavaScript 中最常见的内存泄漏，我们需要了解哪种方式的引用容易被遗忘。 三种类型的常见 JavaScript 内存泄漏1：意外的全局变量JavaScript 处理未定义变量的方式比较宽松：未定义的变量会在全局对象创建一个新变量。在浏览器中，全局对象是 window。 123function foo(arg) &#123; bar = &quot;this is a hidden global variable&quot;;&#125; 真相是： 123function foo(arg) &#123; window.bar = &quot;this is an explicit global variable&quot;;&#125; 函数 foo 内部忘记使用 var ，意外创建了一个全局变量。此例泄漏了一个简单的字符串，无伤大雅，但是有更糟的情况。 另一种意外的全局变量可能由 this 创建： 1234567function foo() &#123; this.variable = &quot;potential accidental global&quot;;&#125;// Foo 调用自己，this 指向了全局对象（window）// 而不是 undefinedfoo(); 在 JavaScript 文件头部加上 &#39;use strict&#39;，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量。 全局变量注意事项 尽管我们讨论了一些意外的全局变量，但是仍有一些明确的全局变量产生的垃圾。它们被定义为不可回收（除非定义为空或重新分配）。尤其当全局变量用于临时存储和处理大量信息时，需要多加小心。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用。高内存消耗导致缓存突破上限，因为缓存内容无法被回收。 2：被遗忘的计时器或回调函数在 JavaScript 中使用 setInterval 非常平常。一段常见的代码： 12345678var someResource = getData();setInterval(function() &#123; var node = document.getElementById(&apos;Node&apos;); if(node) &#123; // 处理 node 和 someResource node.innerHTML = JSON.stringify(someResource)); &#125;&#125;, 1000); 此例说明了什么：与节点或数据关联的计时器不再需要，node 对象可以删除，整个回调函数也不需要了。可是，计时器回调函数仍然没被回收（计时器停止才会被回收）。同时，someResource 如果存储了大量的数据，也是无法被回收的。 对于观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。如今，即使没有明确移除它们，一旦观察者对象变成不可达，大部分浏览器是可以回收观察者处理函数的。 观察者代码示例： 123456var element = document.getElementById(&apos;button&apos;);function onClick(event) &#123; element.innerHTML = &apos;text&apos;;&#125;element.addEventListener(&apos;click&apos;, onClick); 对象观察者和循环引用注意事项 老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。如今，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法，已经可以正确检测和处理循环引用了。换言之，回收节点内存时，不必非要调用 removeEventListener 了。 3：脱离 DOM 的引用有时，保存 DOM 节点内部数据结构很有用。假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用都清除。 1234567891011121314151617181920var elements = &#123; button: document.getElementById(&apos;button&apos;), image: document.getElementById(&apos;image&apos;), text: document.getElementById(&apos;text&apos;)&#125;;function doStuff() &#123; image.src = &apos;http://some.url/image&apos;; button.click(); console.log(text.innerHTML); // 更多逻辑&#125;function removeButton() &#123; // 按钮是 body 的后代元素 document.body.removeChild(document.getElementById(&apos;button&apos;)); // 此时，仍旧存在一个全局的 #button 的引用 // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。&#125; 此外还要考虑 DOM 树内部或子节点的引用问题。假如你的 JavaScript 代码中保存了表格某一个 &lt;td&gt; 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的 &lt;td&gt; 以外的其它节点。实际情况并非如此：此 &lt;td&gt; 是表格的子节点，子元素与父元素是引用关系。由于代码保留了 &lt;td&gt; 的引用，导致整个表格仍待在内存中。保存 DOM 元素引用的时候，要小心谨慎。 4：闭包闭包是 JavaScript 开发的一个关键方面：匿名函数可以访问父级作用域的变量。 代码示例： 1234567891011121314151617var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) console.log(&quot;hi&quot;); &#125;; theThing = &#123; longStr: new Array(1000000).join(&apos;*&apos;), someMethod: function () &#123; console.log(someMessage); &#125; &#125;;&#125;;setInterval(replaceThing, 1000); 代码片段做了一件事情：每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。思绪混乱了吗？最重要的事情是，闭包的作用域一旦创建，它们有同样的父级作用域，作用域是共享的。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。当这段代码反复运行，就会看到内存占用不断上升，垃圾回收器（GC）并无法降低内存占用。本质上，闭包的链表已经创建，每一个闭包作用域携带一个指向大数组的间接的引用，造成严重的内存泄漏。 Meteor 的博文 解释了如何修复此种问题。在 replaceThing 的最后添加 originalThing = null 。 Chrome 内存剖析工具概览Chrome 提供了一套很棒的检测 JavaScript 内存占用的工具。与内存相关的两个重要的工具：timeline 和 profiles。 Timeline timeline 可以检测代码中不需要的内存。在此截图中，我们可以看到潜在的泄漏对象稳定的增长，数据采集快结束时，内存占用明显高于采集初期，Node（节点）的总量也很高。种种迹象表明，代码中存在 DOM 节点泄漏的情况。 Profiles Profiles 是你可以花费大量时间关注的工具，它可以保存快照，对比 JavaScript 代码内存使用的不同快照，也可以记录时间分配。每一次结果包含不同类型的列表，与内存泄漏相关的有 summary（概要） 列表和 comparison（对照） 列表。 summary（概要） 列表展示了不同类型对象的分配及合计大小：shallow size（特定类型的所有对象的总大小），retained size（shallow size 加上其它与此关联的对象大小）。它还提供了一个概念，一个对象与关联的 GC root 的距离。 对比不同的快照的 comparison list 可以发现内存泄漏。 实例：使用 Chrome 发现内存泄漏实质上有两种类型的泄漏：周期性的内存增长导致的泄漏，以及偶现的内存泄漏。显而易见，周期性的内存泄漏很容易发现；偶现的泄漏比较棘手，一般容易被忽视，偶尔发生一次可能被认为是优化问题，周期性发生的则被认为是必须解决的 bug。 以 Chrome 文档中的代码为例： 123456789101112131415161718192021var x = [];function createSomeNodes() &#123; var div, i = 100, frag = document.createDocumentFragment(); for (;i &gt; 0; i--) &#123; div = document.createElement(&quot;div&quot;); div.appendChild(document.createTextNode(i + &quot; - &quot;+ new Date().toTimeString())); frag.appendChild(div); &#125; document.getElementById(&quot;nodes&quot;).appendChild(frag);&#125;function grow() &#123; x.push(new Array(1000000).join(&apos;x&apos;)); createSomeNodes(); setTimeout(grow,1000);&#125; 当 grow 执行的时候，开始创建 div 节点并插入到 DOM 中，并且给全局变量分配一个巨大的数组。通过以上提到的工具可以检测到内存稳定上升。 找出周期性增长的内存timeline 标签擅长做这些。在 Chrome 中打开例子，打开 Dev Tools ，切换到 timeline，勾选 memory 并点击记录按钮，然后点击页面上的 The Button 按钮。过一阵停止记录看结果： 两种迹象显示出现了内存泄漏，图中的 Nodes（绿线）和 JS heap（蓝线）。Nodes 稳定增长，并未下降，这是个显著的信号。 JS heap 的内存占用也是稳定增长。由于垃圾收集器的影响，并不那么容易发现。图中显示内存占用忽涨忽跌，实际上每一次下跌之后，JS heap 的大小都比原先大了。换言之，尽管垃圾收集器不断的收集内存，内存还是周期性的泄漏了。 确定存在内存泄漏之后，我们找找根源所在。 保存两个快照切换到 Chrome Dev Tools 的 profiles 标签，刷新页面，等页面刷新完成之后，点击 Take Heap Snapshot 保存快照作为基准。而后再次点击 The Button 按钮，等数秒以后，保存第二个快照。 筛选菜单选择 Summary，右侧选择 Objects allocated between Snapshot 1 and Snapshot 2，或者筛选菜单选择 Comparison ，然后可以看到一个对比列表。 此例很容易找到内存泄漏，看下 (string) 的 Size Delta Constructor，8MB，58个新对象。新对象被分配，但是没有释放，占用了8MB。 如果展开 (string) Constructor，会看到许多单独的内存分配。选择某一个单独的分配，下面的 retainers 会吸引我们的注意。 我们已选择的分配是数组的一部分，数组关联到 window 对象的 x 变量。这里展示了从巨大对象到无法回收的 root（window）的完整路径。我们已经找到了潜在的泄漏以及它的出处。 我们的例子还算简单，只泄漏了少量的 DOM 节点，利用以上提到的快照很容易发现。对于更大型的网站，Chrome 还提供了 Record Heap Allocations 功能。 Record heap allocations 找内存泄漏回到 Chrome Dev Tools 的 profiles 标签，点击 Record Heap Allocations。工具运行的时候，注意顶部的蓝条，代表了内存分配，每一秒有大量的内存分配。运行几秒以后停止。 上图中可以看到工具的杀手锏：选择某一条时间线，可以看到这个时间段的内存分配情况。尽可能选择接近峰值的时间线，下面的列表仅显示了三种 constructor：其一是泄漏最严重的（string），下一个是关联的 DOM 分配，最后一个是 Textconstructor（DOM 叶子节点包含的文本）。 从列表中选择一个 HTMLDivElement constructor，然后选择 Allocation stack。 现在知道元素被分配到哪里了吧（grow -&gt; createSomeNodes），仔细观察一下图中的时间线，发现 HTMLDivElementconstructor 调用了许多次，意味着内存一直被占用，无法被 GC 回收，我们知道了这些对象被分配的确切位置（createSomeNodes）。回到代码本身，探讨下如何修复内存泄漏吧。 另一个有用的特性在 heap allocations 的结果区域，选择 Allocation。 这个视图呈现了内存分配相关的功能列表，我们立刻看到了 grow 和 createSomeNodes。当选择 grow 时，看看相关的 object constructor，清楚地看到 (string), HTMLDivElement 和 Text 泄漏了。 结合以上提到的工具，可以轻松找到内存泄漏。 延伸阅读 Memory Management - Mozilla Developer Network JScript Memory Leaks - Douglas Crockford (old, in relation to Internet Explorer 6 leaks) JavaScript Memory Profiling - Chrome Developer Docs Memory Diagnosis - Google Developers An Interesting Kind of JavaScript Memory Leak - Meteor blog Grokking V8 closures]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>内存泄露</tag>
        <tag>chrome调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在create-react-app中搭配tslint]]></title>
    <url>%2F2019%2F04%2F24%2Fcreate-react-app-tslint%2F</url>
    <content type="text"><![CDATA[创建React和TypeScript项目现在创建React和TypeScript应用程序非常简单。在CRA 2.1 TypeScript之前，我们必须使用单独的脚本将TypeScript包含在我们的React应用程序中。从CRA 2.1开始，TypeScript支持就在框中。我们只需要安装npm 5.2或更高版本。 创建我们的项目让我们在我们选择的文件夹中运行以下命令，我们要在其中创建项目： 1npx create-react-app app --typescript 该npx工具临时安装create-react-appnpm包并使用它来创建我们的项目。整齐！ 我们选择调用我们的项目应用程序。 我们还指定--typescript了一个位，告诉工具使用TypeScript设置项目。 该工具将花费一分钟左右来创建我们的项目。 添加TSLint将TSLint添加到React和TypeScript有助于我们使代码更具可读性和可维护性。遗憾的是，CRA在其设置中不包含此内容，因此，我们将通过在终端中运行以下命令来自行完成此操作： 123cd appnpm install tslint tslint-react --save-dev 我们刚刚安装了TSLint作为开发依赖项以及React项目的一些标准linting规则。 让我们通过添加一个与以下内容tslint.json 相同级别调用的文件来配置TSLint package.json： 12345&#123; &quot;extends&quot;: [&quot;tslint:latest&quot;, &quot;tslint-react&quot;], &quot;linterOptions&quot;: &#123;&quot;exclude&quot;: [&quot;config/**/*.js&quot;, &quot;node_modules/**/*.ts&quot;, &quot;coverage/lcov-report/*.js&quot;]&#125;&#125; 如果我们希望随着TSLint的发展，linting规则更加稳定，我们可以使用tslint:recommended而不是tslint:latest。 我们可以通过添加字段来覆盖我们想要的特定规则rules。 添加TSLint Visual Studio代码扩展该打字稿TSLint插件 VS代码扩展似乎是最流行的扩展，这些天。 安装此插件后，我们需要启用它tsconfig.json： 12345678&#123; &quot;compilerOptions&quot;: &#123; ..., &quot;plugins&quot;: [&#123;&quot;name&quot;: &quot;typescript-tslint-plugin&quot;&#125;] &#125;, ...&#125; 修复App.tsx中的linting错误现在我们的应用程序正在使用TSLint，我们在App需要修复的组件中遇到了一个小问题。 我们需要在render方法中添加访问修饰符： 123456class App extends Component &#123; public render() &#123; return ( ... ); &#125;&#125; 添加自动格式一些与我们的代码格式有关的linting规则（例如语句末尾的半冒号）可以通过像Prettier这样的工具自动处理。 我们可以通过在终端中执行以下命令来安装Prettier： 1npm install prettier --save-dev 为了让Prettier更好地使用TSLint，我们首先安装 tslint-config-prettier规则预设： 1npm install tslint-config-prettier --save-dev 然后我们将其添加到tslint.json： 1&#123; &quot;extends&quot;: [&quot;tslint:latest&quot;, &quot;tslint-react&quot;, &quot;tslint-config-prettier&quot;], &quot;linterOptions&quot;: &#123;&quot;exclude&quot;: [&quot;config//*.js&quot;, &quot;node_modules//.ts&quot;, &quot;coverage/lcov-report/.js&quot;]&#125;&#125; 我们在.prettierrc文件中指定我们想要的格式规则，该文件位于以下相同的级别package.json： 1&#123; &quot;printWidth&quot;: 80, &quot;singleQuote&quot;: true, &quot;semi&quot;: true, &quot;tabWidth&quot;: 2, &quot;trailingComma&quot;: &quot;all&quot;&#125; 添加更漂亮的Visual Studio代码扩展该更漂亮-代码格式化 VS代码扩展名是流行的扩展，这些天。 通过勾选“ 用户设置”中的“ 保存时格式”选项，我们可以让Prettier在Visual Studio代码中保存文件时应用格式： 运行应用程序像往常一样，我们可以通过在终端中输入以下命令来运行应用程序： npm start 就是这样 - 我们现在有一个带有TSLint和Prettier的React和TypeScript项目！ 参考文档 Creating a React and TypeScript Project 搭建Typescript+React项目模板(5) — 团队规范]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>create-react-app</tag>
        <tag>tslint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongod]]></title>
    <url>%2F2019%2F04%2F22%2Fmongodb%2F</url>
    <content type="text"><![CDATA[mongodb密码和传统数据如mysql等有些区别： mongodb的用户名和密码是基于特定数据库的，而不是基于整个系统的。所有所有数据库db都需要设置密码 mongodb设置管理用户和密码： show dbs在mongodb新版本里并没有admin数据库，但是并不妨碍第2步操作。 use admin 进入admin数据库 创建管理员账户db.createUser({ user: &quot;useradmin&quot;, pwd: &quot;adminpassword&quot;, roles: [{ role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; }] })mongodb中的用户是基于身份role的，该管理员账户的 role是 userAdminAnyDatabase。 ‘userAdmin’代表用户管理身份，’AnyDatabase’ 代表可以管理任何数据库。 验证第3步用户添加是否成功db.auth(&quot;useradmin&quot;, &quot;adminpassword&quot;) 如果返回1，则表示成功。exit退出系统db.auth()方法理解为 用户的验证功能 修改配置 1sudo vi /etc/mongod.conf ​ 找到 1#security: 取消注释，修改为： security: authorization: enabled #注意缩进，缩进参照配置文件其他配置。缩进错误可能第6步重启不成功。 重启mongodb sudo service mongod restart 进入mongodb,用第3步的 管理员账户登录，用该账户创建其他数据库管理员账号 use admin db.auth(&quot;useradmin&quot;, &quot;adminpassword&quot;) 新建你需要管理的mongodb 数据的账号密码。 #必须要use否则创建的不生效,连接也不生效，否则连接的时候只能用admin的数据库去连rotbo3T，但也可以看到自己的Database,也可以操作数据库 use yourdatabase db.createUser({ user: &quot;youruser&quot;, pwd: &quot;yourpassword&quot;, roles: [{ role: &quot;dbOwner&quot;, db: &quot;yourdatabase&quot; }] }) rote:dbOwner 代表数据库所有者角色，拥有最高该数据库最高权限。比如新建索引等 新建数据库读写账户 use yourdatabase db.createUser({ user: &quot;youruser2&quot;, pwd: &quot;yourpassword2&quot;, roles: [{ role: &quot;readWrite&quot;, db: &quot;yourdatabase&quot; }] }) 该用户用于该数据的读写，只拥有读写权限。 现在数据的用户名和密码就建好了。可以使用：mongodb://youruser2:yourpassword2@localhost/yourdatabase来链接 验证ps aux|grep mongo 12345mongod 3609 0.2 8.6 1087064 87484 ? Sl 13:32 0:30 /usr/bin/mongod -f /etc/mongod.confroot 4150 0.0 0.0 112724 988 pts/0 R+ 17:10 0:00 grep --color=auto mongo没起服务之前root 3574 0.0 0.0 112724 988 pts/0 R+ 13:28 0:00 grep --color=auto mongo 验证安全认证： use adminwitched to db adminshow dbs –没有认证查看数据库报错014-09-14T13:28:45.953+0800 listDatabases failed:{ “ok” : 0, “errmsg” : “not authorized on admin to execute command { listDatabases:.0 }”, “code” : 13 at src/mongo/shell/mongo.js:47 db.auth(“super”,”super”) —认证后再次查看ok1show dbsdmin 0.078GBocal 0.078GBest 0.078GBangwei 0.078GB 普通用户认证 show dbs –没有认证查看数据014-09-14T13:31:19.265+0800 listDatabases failed:{ “ok” : 0, “errmsg” : “not authorized on admin to execute command { listDatabases:.0 }”, “code” : 13 at src/mongo/shell/mongo.js:47 db.auth(“test”,”test”)1show dbs –认证后查看数据库还报错，原因这个用户属于test不属于admin014-09-14T13:33:30.062+0800 listDatabases failed:{ “ok” : 0, “errmsg” : “not authorized on admin to execute command { listDatabases:.0 }”, “code” : 13 at src/mongo/shell/mongo.js:47 E:\mongodb\bin&gt;mongo 127.0.0.1:27019MongoDB shell version: 2.6.4connecting to: 127.0.0.1:27019/test db.mycol.insert({“id”:222}) –没有认证情况插入文档失败WriteResult({ “writeError” : { “code” : 13, “errmsg” : “not authorized on test to execute command { insert:“mycol\”, documents: [ { _id: ObjectId(‘5415292f131751676caa7881’), id: 222.0 }], ordered: true }” }})db.auth(“test”,”test”) –认证后插入文档成功1db.mycol.insert({“id”:222})riteResult({ “nInserted” : 1 }) 只读用户认证E:\mongodb\bin&gt;mongo 127.0.0.1:27019MongoDB shell version: 2.6.4connecting to: 127.0.0.1:27019/test db.mycol.find() –没有认证查询失败rror: { “$err” : “not authorized for query on test.mycol”, “code” : 13 }db.auth(“readonly”.”readonly”)014-09-14T13:38:16.265+0800 SyntaxError: Unexpected stringdb.auth(“readonly”,”readonly”)1db.mycol.find() –认证后查询成功 “_id” : ObjectId(“5415294b131751676caa7882”), “id” : 222 } db.mycol.insert({“id”:5555}) –只读认证后，插入文档失败，原因用户是只读的WriteResult({ “writeError” : { “code” : 13, “errmsg” : “not authorized on test to execute command { insert:“mycol\”, documents: [ { _id: ObjectId(‘541529ead090e8f5c50762b9’), id: 5555.0 ], ordered: true }” }}) 参考文档 mongodb设置密码 MongoDB 基础（六）安全性（权限操作） mongodb的用户认证]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb-config</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb]]></title>
    <url>%2F2019%2F04%2F12%2Fmongodb%2F</url>
    <content type="text"><![CDATA[db.collection.aggregate()除了$out和$geoNear阶段之外的所有内容都可以在管道中多次出现 计算集合或视图中数据的聚合值 1db.collection.aggregate(pipeline, options) 参数 类型 描述 pipeline 排列 一系列数据聚合操作或阶段。有关详细信息，请参阅 聚合管道运算在2.6版中更改：该方法仍然可以将管道阶段作为单独的参数接受，而不是作为数组中的元素; 但是，如果未指定pipeline为数组，则无法指定 options参数。 options 文献 可选的。aggregate()传递给aggregate命令的其他选项。版本2.6中的新功能：仅在您指定pipeline为数组时可用。 该options文档可以包含以下字段和值： 领域 类型 描述 explain 布尔 可选的。指定返回有关管道处理的信息。有关示例，请参阅 聚合管道操作的返回信息。在多文档交易中不可用。 allowDiskUse 布尔 可选的。允许写入临时文件。设置为时true，聚合操作可以将数据写入_tmp目录中的 dbPath子目录。有关示例，请参阅 使用外部排序执行大型排序操作。2.6版中的新功能。 cursor 文献 可选的。指定游标的初始批处理大小。该cursor 字段的值是具有该字段的文档batchSize。有关语法和示例，请参阅 指定初始批处理大小。2.6版中的新功能。 maxTimeMS 非负整数 可选的。指定处理游标操作的时间限制（以毫秒为单位）。如果未指定maxTimeMS的值，则操作不会超时。值0显式指定默认的无界行为。MongoDB使用与其相同的机制终止超出其分配时间限制的操作db.killOp()。MongoDB仅终止其指定中断点之一的操作。 bypassDocumentValidation 布尔 可选的。仅在指定$out聚合运算符时可用。允许db.collection.aggregate在操作期间绕过文档验证。这使您可以插入不符合验证要求的文档。版本3.2中的新功能。 readConcern 文献 可选的。指定读取问题。readConcern选项具有以下语法：版本3.6中已更改。复制复制readConcern ： { level ： &lt; value &gt; }可能的阅读关注水平是：&quot;local&quot;。这是默认的读取关注级别。&quot;available&quot;。当读取操作和afterClusterTime以及“level”未指定时，这是对辅助节点的读取的默认值。查询返回实例的最新数据。&quot;majority&quot;。适用于使用WiredTiger存储引擎的副本集 。&quot;linearizable&quot;。仅适用于读取操作 primary。有关读取关注级别的更多信息，请参阅 读取关注级别。对于&quot;local&quot;（默认）或&quot;majority&quot;读取关注级别，您可以指定使afterClusterTime读取操作返回满足级别要求的数据和指定的群集时间要求的选项。有关更多信息，请参阅 读取操作和afterClusterTime。 collation 文献 可选的。指定 要用于操作的排序规则。排序规则允许用户为字符串比较指定特定于语言的规则，例如字母和重音标记的规则。排序规则选项具有以下语法：复制复制collation ： { locale ： &lt; string &gt; ， caseLevel ： &lt; boolean &gt; ， caseFirst ： &lt; string &gt; ， strength ： &lt; int &gt; ， numericOrdering ： &lt; boolean &gt; ， alternate ： &lt; string &gt; ， maxVariable ： &lt; string &gt; ， backwards ： &lt; boolean &gt; }指定排序规则时，该locale字段是必填字段; 所有其他校对字段都是可选的。有关字段的说明，请参阅排序文档。如果未指定排序规则但集合具有默认排序规则（请参阅参考资料db.createCollection()），则该操作将使用为集合指定的排序规则。如果没有为集合或操作指定排序规则，MongoDB使用先前版本中使用的简单二进制比较进行字符串比较。您无法为操作指定多个排序规则。例如，您不能为每个字段指定不同的排序规则，或者如果使用排序执行查找，则不能对查找使用一个排序规则，而对排序使用另一个排序规则。版本3.4中的新功能。 hint 字符串或文件 可选的。用于聚合的索引。索引位于运行聚合的初始集合/视图上。通过索引名称或索引规范文档指定索引。注意该hint不适$lookup和 $graphLookup阶段。版本3.6中的新功能。 comment 串 可选的。用户可以指定任意字符串，以帮助通过数据库探查器，currentOp和日志跟踪操作。版本3.6中的新功能。 一个光标通过聚集流水线操作的最后阶段产生的文件，或者如果包括 explain选项，提供了聚集操作的处理细节的文件。 阶段 描述 $addFields 向文档添加新字段。类似于 $project，$addFields重塑流中的每个文档; 具体而言，通过向输出文档添加新字段，该文档包含输入文档和新添加字段中的现有字段。 $bucket 根据指定的表达式和存储区边界，将传入的文档分组，称为存储桶。 $bucketAuto 根据指定的表达式将传入的文档分类为特定数量的组（称为存储桶）。自动确定存储桶边界，以尝试将文档均匀地分配到指定数量的存储桶中。 $collStats 返回有关集合或视图的统计信息。 $count 返回聚合管道此阶段的文档数量计数。 $facet 在同一组输入文档的单个阶段内处理多个聚合管道。支持创建能够在单个阶段中跨多个维度或方面表征数据的多面聚合。 $geoNear 基于与地理空间点的接近度返回有序的文档流。集成的功能 $match，$sort以及$limit地理空间数据。输出文档包括附加距离字段，并且可以包括位置标识符字段。 $graphLookup 对集合执行递归搜索。对于每个输出文档，添加一个新的数组字段，其中包含该文档的递归搜索的遍历结果。 $group 按指定的标识符表达式对文档进行分组，并将累加器表达式（如果已指定）应用于每个组。消耗所有输入文档，并为每个不同的组输出一个文档。输出文档仅包含标识符字段，如果指定，则包含累积字段。 $indexStats 返回有关集合的每个索引的使用的统计信息。 $limit 将未修改的前n个文档传递给管道，其中n是指定的限制。对于每个输入文档，输出一个文档（对于前n个文档）或零文档（在前n个文档之后）。 $listSessions 列出活动时间足以传播到system.sessions集合的所有会话。 $lookup 对同一数据库中的另一个集合执行左外连接，以 从“已连接”集合中过滤文档以进行处理。 $match 过滤文档流以仅允许匹配的文档未经修改地传递到下一个管道阶段。 $match使用标准的MongoDB查询。对于每个输入文档，输出一个文档（匹配）或零文档（不匹配）。 $out 将聚合管道的结果文档写入集合。要使用$out舞台，它必须是管道中的最后一个阶段。 $project 重新整形流中的每个文档，例如添加新字段或删除现有字段。对于每个输入文档，输出一个文档。 $redact 通过基于文档本身中存储的信息限制每个文档的内容来重塑流中的每个文档。包含$project和的功能 $match。可用于实现字段级别的编辑。对于每个输入文档，输出一个或零个文档。 $replaceRoot 用指定的嵌入文档替换文档。该操作将替换输入文档中的所有现有字段，包括_id字段。指定嵌入在输入文档中的文档以将嵌入文档提升到顶层。 $sample 从输入中随机选择指定数量的文档。 $skip 跳过前n个文档，其中n是指定的跳过编号，并将未修改的其余文档传递给管道。对于每个输入文档，输出零文档（对于前n个文档）或一个文档（如果在前n个文档之后）。 $sort 按指定的排序键重新排序文档流。只有订单改变; 文件保持不变。对于每个输入文档，输出一个文档。 $sortByCount 根据指定表达式的值对传入文档进行分组，然后计算每个不同组中的文档计数。 $unwind 从输入文档解构数组字段以输出每个元素的文档。每个输出文档都使用元素值替换数组。对于每个输入文档，输出n个文档，其中n是数组元素的数量，对于空数组，可以为零。 对于要在管道阶段中使用的聚合表达式运算符，请参阅 聚合管道运算符。 1expression：聚合表达式 db.aggregate()从3.6版开始，MongoDB还提供了以下 db.aggregate方法：以下阶段使用db.aggregate()方法而不是db.collection.aggregate()方法。 阶段 描述 $currentOp 返回有关MongoDB部署的活动和/或休眠操作的信息。 $listLocalSessions 列出最近在当前连接mongos或mongod 实例上使用的所有活动会话。这些会话可能尚未传播到system.sessions集合中。 聚合api$project（更改原有字段的输出，维度是_id，即每一条数据不变） 将包含请求字段的文档传递到管道中的下一个阶段。指定的字段可以是输入文档或新计算字段中的现有字段。 1&#123; $project: &#123; &lt;specification(s)&gt; &#125; &#125; 该$project需要，可以指定包含字段的压制文档_id领域，增加新的字段，以及现有字段的值的复位。或者，您可以指定 字段的排除。 该$project规范有以下几种形式： 形成 描述 &lt;field&gt;: &lt;1 or true&gt; 指定包含字段。 _id: &lt;0 or false&gt; 指定_id字段的抑制。要有条件地排除字段，请改用REMOVE 变量。有关详细信息，请参阅有条件地排除字段。 &lt;field&gt;: &lt;expression&gt; 添加新字段或重置现有字段的值。在版本3.6中更改： MongoDB 3.6添加了变量REMOVE。如果表达式求值为$$REMOVE，则在输出中排除该字段。有关详细信息，请参阅有条件地排除字段。 &lt;field&gt;:&lt;0 or false&gt; 版本3.4中的新功能。指定排除字段。要有条件地排除字段，请改用REMOVE 变量。有关详细信息，请参阅有条件地排除字段。如果您指定排除其他字段_id，则不能使用任何其他$project 规范表单。此限制不适用于使用REMOVE 变量有条件地排除字段。 注意事项包含现有字段 _id默认情况下，该字段包含在输出文档中。要在输出文档中包含输入文档中的任何其他字段，必须明确指定包含在中 $project。 如果指定包含文档中不存在的字段，则$project忽略该字段包含，并且不将该字段添加到文档中。 取消_id字段默认情况下，该_id字段包含在输出文档中。要从_id输出文档中排除字段，必须明确指定_id字段 的抑制$project。 排除字段版本3.4中的新功能。 如果指定排除某个或多个字段，则在输出文档中返回所有其他字段。 如果指定排除除以外的字段_id，则不能使用任何其他$project规范表单：即，如果排除字段，则不能指定包含字段，重置现有字段的值或添加新字段。此限制不适用于使用REMOVE变量对字段进行条件排除 。 有条件地排除字段版本3.6中的新功能。 从MongoDB 3.6开始，您可以使用REMOVE聚合表达式中的变量来有条件地抑制字段。有关示例，请参阅有条件排除字段。 添加新字段或重置现有字段要添加新字段或重置现有字段的值，请指定字段名称并将其值设置为某个表达式。有关表达式的更多信息，请参阅表达式。 文字值若要将字段值直接设置为数字或布尔文字，而不是将字段设置为解析为文字的表达式，请使用$literal运算符。否则， $project将数字或布尔文字视为包含或排除字段的标志。 字段重命名通过指定新字段并将其值设置为现有字段的字段路径，可以有效地重命名字段。 新数组字段从MongoDB 3.2开始，$projectstage支持使用方括号[]直接创建新的数组字段。如果数组规范包含文档中不存在的字段，则该操作将替换null为该字段的值。有关示例，请参阅Project New Array Fields。 嵌入文档字段在嵌入文档中投影或添加/重置字段时，您可以使用点表示法，如 &quot;contact.address.country&quot;: &lt;1 or 0 or expression&gt; contact: { address: { country: &lt;1 or 0 or expression&gt; } } 当嵌套的领域，你不能使用点表示法嵌入文档中指定的领域，比如是无效的。contact: {&quot;address.country&quot;: &lt;1 or 0 or expression&gt; } 限制在版本3.4中更改。 如果$project 规范是空文档，MongoDB 3.4及更高版本会产生错误。 示例1.在输出文档中包含特定字段考虑一个books包含以下文档的集合： 1234567891011121314&#123; &quot;_id&quot; : 1, title: &quot;abc123&quot;, isbn: &quot;0001122223334&quot;, author: &#123; last: &quot;zzz&quot;, first: &quot;aaa&quot; &#125;, copies: 5&#125;$project阶段只包括_id， title和author在其输出文档的字段：db.books.aggregate( [ &#123; $project : &#123; title : 1 , author : 1 &#125; &#125; ] )结果&#123; &quot;_id&quot; : 1, &quot;title&quot; : &quot;abc123&quot;, &quot;author&quot; : &#123; &quot;last&quot; : &quot;zzz&quot;, &quot;first&quot; : &quot;aaa&quot; &#125; &#125; 2.抑制_id输出文档中的字段_id默认情况下始终包含该字段。要从舞台_id 的输出文档中$project排除该_id字段，请通过0在投影文档中将其设置为指定字段的排除。 考虑一个books包含以下文档的集合： 12345678910111213&#123; &quot;_id&quot; : 1, title: &quot;abc123&quot;, isbn: &quot;0001122223334&quot;, author: &#123; last: &quot;zzz&quot;, first: &quot;aaa&quot; &#125;, copies: 5&#125;以下$project阶段排除了该_id字段，但包括其输出文档中title的author字段和字段：db.books.aggregate( [ &#123; $project : &#123; _id: 0, title : 1 , author : 1 &#125; &#125; ] )结果&#123; &quot;title&quot; : &quot;abc123&quot;, &quot;author&quot; : &#123; &quot;last&quot; : &quot;zzz&quot;, &quot;first&quot; : &quot;aaa&quot; &#125; &#125; 3.从输出文档中排除字段版本3.4中的新功能。 考虑一个books包含以下文档的集合 1234567891011&#123; &quot;_id&quot; : 1, title: &quot;abc123&quot;, isbn: &quot;0001122223334&quot;, author: &#123; last: &quot;zzz&quot;, first: &quot;aaa&quot; &#125;, copies: 5, lastModified: &quot;2016-07-28&quot;&#125;以下$project阶段lastModified 从输出中排除字段db.books.aggregate( [ &#123; $project : &#123; &quot;lastModified&quot;: 0 &#125; &#125; ] ) 从嵌入式文档中排除字段版本3.4中的新功能。 考虑一个books包含以下文档的集合 12345678910111213141516171819202122232425&#123; &quot;_id&quot; : 1, title: &quot;abc123&quot;, isbn: &quot;0001122223334&quot;, author: &#123; last: &quot;zzz&quot;, first: &quot;aaa&quot; &#125;, copies: 5, lastModified: &quot;2016-07-28&quot;&#125;以下$project阶段从输出中排除author.first 和lastModified字段：db.books.aggregate( [ &#123; $project : &#123; &quot;author.first&quot; : 0, &quot;lastModified&quot; : 0 &#125; &#125; ] )或者，您可以将排除规范嵌套在文档中：db.bookmarks.aggregate( [ &#123; $project: &#123; &quot;author&quot;: &#123; &quot;first&quot;: 0&#125;, &quot;lastModified&quot; : 0 &#125; &#125; ] )两种规格都会产生相同的输出：&#123; &quot;_id&quot; : 1, &quot;title&quot; : &quot;abc123&quot;, &quot;isbn&quot; : &quot;0001122223334&quot;, &quot;author&quot; : &#123; &quot;last&quot; : &quot;zzz&quot; &#125;, &quot;copies&quot; : 5,&#125; 4.有条件地排除字段版本3.6中的新功能。 从MongoDB 3.6开始，您可以使用REMOVE聚合表达式中的变量来有条件地抑制字段。 考虑一个books包含以下文档的集合： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#123; &quot;_id&quot; : 1, title: &quot;abc123&quot;, isbn: &quot;0001122223334&quot;, author: &#123; last: &quot;zzz&quot;, first: &quot;aaa&quot; &#125;, copies: 5, lastModified: &quot;2016-07-28&quot;&#125;&#123; &quot;_id&quot; : 2, title: &quot;Baked Goods&quot;, isbn: &quot;9999999999999&quot;, author: &#123; last: &quot;xyz&quot;, first: &quot;abc&quot;, middle: &quot;&quot; &#125;, copies: 2, lastModified: &quot;2017-07-21&quot;&#125;&#123; &quot;_id&quot; : 3, title: &quot;Ice Cream Cakes&quot;, isbn: &quot;8888888888888&quot;, author: &#123; last: &quot;xyz&quot;, first: &quot;abc&quot;, middle: &quot;mmm&quot; &#125;, copies: 5, lastModified: &quot;2017-07-22&quot;&#125;以下$project阶段仅在等于以下情况时才使用该REMOVE 变量排除该author.middle字段&quot;&quot;：db.books.aggregate( [ &#123; $project: &#123; title: 1, &quot;author.first&quot;: 1, &quot;author.last&quot; : 1, &quot;author.middle&quot;: &#123; $cond: &#123; if: &#123; $eq: [ &quot;&quot;, &quot;$author.middle&quot; ] &#125;, then: &quot;$$REMOVE&quot;, else: &quot;$author.middle&quot; &#125; &#125; &#125; &#125;] )聚合操作会产生以下输出：&#123; &quot;_id&quot; : 1, &quot;title&quot; : &quot;abc123&quot;, &quot;author&quot; : &#123; &quot;last&quot; : &quot;zzz&quot;, &quot;first&quot; : &quot;aaa&quot; &#125; &#125;&#123; &quot;_id&quot; : 2, &quot;title&quot; : &quot;Baked Goods&quot;, &quot;author&quot; : &#123; &quot;last&quot; : &quot;xyz&quot;, &quot;first&quot; : &quot;abc&quot; &#125; &#125;&#123; &quot;_id&quot; : 3, &quot;title&quot; : &quot;Ice Cream Cakes&quot;, &quot;author&quot; : &#123; &quot;last&quot; : &quot;xyz&quot;, &quot;first&quot; : &quot;abc&quot;, &quot;middle&quot; : &quot;mmm&quot; &#125; &#125; 5.包含嵌入式文档中的特定字段考虑一个bookmarks包含以下文档的集合： 123456789101112&#123; _id: 1, user: &quot;1234&quot;, stop: &#123; title: &quot;book1&quot;, author: &quot;xyz&quot;, page: 32 &#125; &#125;&#123; _id: 2, user: &quot;7890&quot;, stop: [ &#123; title: &quot;book2&quot;, author: &quot;abc&quot;, page: 5 &#125;, &#123; title: &quot;book3&quot;, author: &quot;ijk&quot;, page: 100 &#125; ] &#125;要仅在title字段中包含嵌入文档中的 stop字段，可以使用点表示法db.bookmarks.aggregate( [ &#123; $project: &#123; &quot;stop.title&quot;: 1 &#125; &#125; ] )或者，您可以将包含规范嵌套在文档中：db.bookmarks.aggregate( [ &#123; $project: &#123; stop: &#123; title: 1 &#125; &#125; &#125; ] )这两个规范都会产生以下文件：&#123; &quot;_id&quot; : 1, &quot;stop&quot; : &#123; &quot;title&quot; : &quot;book1&quot; &#125; &#125;&#123; &quot;_id&quot; : 2, &quot;stop&quot; : [ &#123; &quot;title&quot; : &quot;book2&quot; &#125;, &#123; &quot;title&quot; : &quot;book3&quot; &#125; ] &#125; 6.包含计算字段考虑一个books包含以下文档的集合： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; &quot;_id&quot; : 1, title: &quot;abc123&quot;, isbn: &quot;0001122223334&quot;, author: &#123; last: &quot;zzz&quot;, first: &quot;aaa&quot; &#125;, copies: 5&#125;下$project阶段增加了新的领域 isbn，lastName以及copiesSold：db.books.aggregate( [ &#123; $project: &#123; title: 1, isbn: &#123; prefix: &#123; $substr: [ &quot;$isbn&quot;, 0, 3 ] &#125;, group: &#123; $substr: [ &quot;$isbn&quot;, 3, 2 ] &#125;, publisher: &#123; $substr: [ &quot;$isbn&quot;, 5, 4 ] &#125;, title: &#123; $substr: [ &quot;$isbn&quot;, 9, 3 ] &#125;, checkDigit: &#123; $substr: [ &quot;$isbn&quot;, 12, 1] &#125; &#125;, lastName: &quot;$author.last&quot;, copiesSold: &quot;$copies&quot; &#125; &#125; ])操作结果如下：&#123; &quot;_id&quot; : 1, &quot;title&quot; : &quot;abc123&quot;, &quot;isbn&quot; : &#123; &quot;prefix&quot; : &quot;000&quot;, &quot;group&quot; : &quot;11&quot;, &quot;publisher&quot; : &quot;2222&quot;, &quot;title&quot; : &quot;333&quot;, &quot;checkDigit&quot; : &quot;4&quot; &#125;, &quot;lastName&quot; : &quot;zzz&quot;, &quot;copiesSold&quot; : 5&#125; 7.项目新数组字段例如，如果集合包含以下文档： 12345678&#123; &quot;_id&quot; : ObjectId(&quot;55ad167f320c6be244eb3b95&quot;), &quot;x&quot; : 1, &quot;y&quot; : 1 &#125;以下操作将字段x和y元素作为新字段的项目myArray：db.collection.aggregate( [ &#123; $project: &#123; myArray: [ &quot;$x&quot;, &quot;$y&quot; ] &#125; &#125; ] )&#123; &quot;_id&quot; : ObjectId(&quot;55ad167f320c6be244eb3b95&quot;), &quot;myArray&quot; : [ 1, 1 ] &#125; 如果数组规范包含文档中不存在的字段，则该操作将替换null为该字段的值。 例如，给定相同的文档如上述，以下的动作项目的字段x，y以及一个不存在的字段 $someField作为一个新的领域元素myArray： 1234db.collection.aggregate( [ &#123; $project: &#123; myArray: [ &quot;$x&quot;, &quot;$y&quot;, &quot;$someField&quot; ] &#125; &#125; ] )&#123; &quot;_id&quot; : ObjectId(&quot;55ad167f320c6be244eb3b95&quot;), &quot;myArray&quot; : [ 1, 1, null ] &#125; $out 获取聚合管道返回的文档并将它们写入指定的集合。该$out操作者必须在最后阶段的管道。 版本3.2.0中已更改： MongoDB 3.2添加了对文档验证的支持。该bypassDocumentValidation 字段使您可以$out在聚合操作阶段绕过文档验证 。这使您可以插入不符合验证要求的文档。指定bypassDocumentValidation聚合方法或命令的选项。 { $out: &quot;&lt;output-collection&gt;&quot; } $out 获取一个指定输出集合名称的字符串。 重要 您不能将分片集合指定为输出集合。管道的输入集合可以分片。 该$out运营商不能将结果写入 封顶集合。 行为创建新集合$out如果当前数据库尚不存在，则该操作将在当前数据库中创建新集合。在聚合完成之前，集合不可见。如果聚合失败，MongoDB不会创建集合。 替换现有集合如果$out操作指定的集合已存在，则在完成聚合后，该$out 阶段将使用新结果集合原子替换现有集合。具体来说，$out操作： 创建临时集合。 将索引从现有集合复制到临时集合。 将文档插入临时集合中。 调用db.collection.renameCollection与 到临时集合重命名为目的地集合。dropTarget: true 该$out操作不会更改先前集合中存在的任何索引。如果聚合失败，则$out操作不会对预先存在的集合进行任何更改。 索引约束如果管道生成的文档违反任何唯一索引（包括_id原始输出集合字段的索引），则管道将无法完成 。 交易$out在交易中不允许。 示例集合books包含以下文档： 12345678910111213141516&#123; &quot;_id&quot; : 8751, &quot;title&quot; : &quot;The Banquet&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 2 &#125;&#123; &quot;_id&quot; : 8752, &quot;title&quot; : &quot;Divine Comedy&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 1 &#125;&#123; &quot;_id&quot; : 8645, &quot;title&quot; : &quot;Eclogues&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 2 &#125;&#123; &quot;_id&quot; : 7000, &quot;title&quot; : &quot;The Odyssey&quot;, &quot;author&quot; : &quot;Homer&quot;, &quot;copies&quot; : 10 &#125;&#123; &quot;_id&quot; : 7020, &quot;title&quot; : &quot;Iliad&quot;, &quot;author&quot; : &quot;Homer&quot;, &quot;copies&quot; : 10 &#125;以下聚合操作将books 集合中的数据转向以按作者分组标题，然后将结果写入authors集合。db.books.aggregate( [ &#123; $group : &#123; _id : &quot;$author&quot;, books: &#123; $push: &quot;$title&quot; &#125; &#125; &#125;, &#123; $out : &quot;authors&quot; &#125; ] ) &#123; &quot;_id&quot; : &quot;Homer&quot;, &quot;books&quot; : [ &quot;The Odyssey&quot;, &quot;Iliad&quot; ] &#125;&#123; &quot;_id&quot; : &quot;Dante&quot;, &quot;books&quot; : [ &quot;The Banquet&quot;, &quot;Divine Comedy&quot;, &quot;Eclogues&quot; ] &#125; $group（根据不同的字段进行统计，或者输出） 按一些指定的表达式对文档进行分组，并为每个不同的分组输出到下一个阶段的文档。输出文档包含一个_id按键包含不同组的字段。输出文档还可以包含存储由分组一些累加器表达式的值来计算字段 $group的_id字段。$group并没有 责令其输出文档。 该$group阶段具有以下原型形式： 1&#123; $ group ： &#123;_ id ： &lt; expression &gt; ， &lt; field1 &gt;： &#123; &lt; accumulator1 &gt; ： &lt; expression1 &gt; &#125;， ... &#125; &#125; 该_id字段是强制性的 ; 但是，您可以指定 _idnull值或任何其他常量值，以计算所有输入文档的累计值。 其余的计算字段是可选的，并使用&lt;accumulator&gt;运算符计算 。 在_id和&lt;accumulator&gt;表达式可以接受任何有效的表达。有关表达式的更多信息，请参阅表达式 注意事项累加运算符该&lt;accumulator&gt;操作必须是以下之一： 名称 描述 $addToSet 返回每个组的唯一表达式值数组。数组元素的顺序未定义。 $avg 返回数值的平均值。忽略非数字值。 $first 返回每个组的第一个文档中的值。仅在文档按定义的顺序定义时才定义订单。 $last 返回每个组的最后一个文档的值。仅在文档按定义的顺序定义时才定义订单。 $max 返回每个组的最高表达式值。 $mergeObjects 返回通过组合每个组的输入文档创建的文档。 $min 返回每个组的最低表达式值。 $push 返回每个组的表达式值数组。 $stdDevPop 返回输入值的总体标准偏差。 $stdDevSamp 返回输入值的样本标准偏差。 $sum 返回数值的总和。忽略非数字值。 $group运算符和内存该$group阶段的RAM限制为100兆字节。默认情况下，如果阶段超出此限制，$group将产生错误。但是，要允许处理大型数据集，请将allowDiskUse选项设置 true为启用$group操作以写入临时文件。有关详细信息，请参阅db.collection.aggregate()方法和 aggregate命令。 版本2.6中更改： MongoDB为$group舞台引入了100兆字节的RAM限制， 以及allowDiskUse处理大型数据集操作的选项。 示例1.计算计数，总和和平均值给出sales包含以下文档的集合： 12345&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;abc&quot;, &quot;price&quot; : 10, &quot;quantity&quot; : 2, &quot;date&quot; : ISODate(&quot;2014-03-01T08:00:00Z&quot;) &#125;&#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;jkl&quot;, &quot;price&quot; : 20, &quot;quantity&quot; : 1, &quot;date&quot; : ISODate(&quot;2014-03-01T09:00:00Z&quot;) &#125;&#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;xyz&quot;, &quot;price&quot; : 5, &quot;quantity&quot; : 10, &quot;date&quot; : ISODate(&quot;2014-03-15T09:00:00Z&quot;) &#125;&#123; &quot;_id&quot; : 4, &quot;item&quot; : &quot;xyz&quot;, &quot;price&quot; : 5, &quot;quantity&quot; : 20, &quot;date&quot; : ISODate(&quot;2014-04-04T11:21:39.736Z&quot;) &#125;&#123; &quot;_id&quot; : 5, &quot;item&quot; : &quot;abc&quot;, &quot;price&quot; : 10, &quot;quantity&quot; : 10, &quot;date&quot; : ISODate(&quot;2014-04-04T21:23:13.331Z&quot;) &#125; 按月，日和年分组以下聚合操作使用$group阶段按月，日和年对文档进行分组，并计算总价格和平均数量，并计算每个组的文档： 123456789101112131415161718db.sales.aggregate( [ &#123; $group : &#123; _id : &#123; month: &#123; $month: &quot;$date&quot; &#125;, day: &#123; $dayOfMonth: &quot;$date&quot; &#125;, year: &#123; $year: &quot;$date&quot; &#125; &#125;, totalPrice: &#123; $sum: &#123; $multiply: [ &quot;$price&quot;, &quot;$quantity&quot; ] &#125; &#125;, averageQuantity: &#123; $avg: &quot;$quantity&quot; &#125;, count: &#123; $sum: 1 &#125; &#125; &#125; ])&#123; &quot;_id&quot; : &#123; &quot;month&quot; : 3, &quot;day&quot; : 15, &quot;year&quot; : 2014 &#125;, &quot;totalPrice&quot; : 50, &quot;averageQuantity&quot; : 10, &quot;count&quot; : 1 &#125;&#123; &quot;_id&quot; : &#123; &quot;month&quot; : 4, &quot;day&quot; : 4, &quot;year&quot; : 2014 &#125;, &quot;totalPrice&quot; : 200, &quot;averageQuantity&quot; : 15, &quot;count&quot; : 2 &#125;&#123; &quot;_id&quot; : &#123; &quot;month&quot; : 3, &quot;day&quot; : 1, &quot;year&quot; : 2014 &#125;, &quot;totalPrice&quot; : 40, &quot;averageQuantity&quot; : 1.5, &quot;count&quot; : 2 &#125; 2.分组null下面的聚合操作指定一组_id的 null，计算总价格和平均数量以及计数集合中的所有文件： 123456789101112131415db.sales.aggregate( [ &#123; $group : &#123; _id : null, totalPrice: &#123; $sum: &#123; $multiply: [ &quot;$price&quot;, &quot;$quantity&quot; ] &#125; &#125;, averageQuantity: &#123; $avg: &quot;$quantity&quot; &#125;, count: &#123; $sum: 1 &#125; &#125; &#125; ])// result&#123; &quot;_id&quot; : null, &quot;totalPrice&quot; : 290, &quot;averageQuantity&quot; : 8.6, &quot;count&quot; : 5 &#125; 也可以看看 $count 3.检索不同的值给出sales包含以下文档的集合： 123456789101112131415&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;abc&quot;, &quot;price&quot; : 10, &quot;quantity&quot; : 2, &quot;date&quot; : ISODate(&quot;2014-03-01T08:00:00Z&quot;) &#125;&#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;jkl&quot;, &quot;price&quot; : 20, &quot;quantity&quot; : 1, &quot;date&quot; : ISODate(&quot;2014-03-01T09:00:00Z&quot;) &#125;&#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;xyz&quot;, &quot;price&quot; : 5, &quot;quantity&quot; : 10, &quot;date&quot; : ISODate(&quot;2014-03-15T09:00:00Z&quot;) &#125;&#123; &quot;_id&quot; : 4, &quot;item&quot; : &quot;xyz&quot;, &quot;price&quot; : 5, &quot;quantity&quot; : 20, &quot;date&quot; : ISODate(&quot;2014-04-04T11:21:39.736Z&quot;) &#125;&#123; &quot;_id&quot; : 5, &quot;item&quot; : &quot;abc&quot;, &quot;price&quot; : 10, &quot;quantity&quot; : 10, &quot;date&quot; : ISODate(&quot;2014-04-04T21:23:13.331Z&quot;) &#125;以下聚合操作使用该$group阶段按项目对文档进行分组以检索不同的项目值：db.sales.aggregate( [ &#123; $group : &#123; _id : &quot;$item&quot; &#125; &#125; ] )// result&#123; &quot;_id&quot; : &quot;xyz&quot; &#125;&#123; &quot;_id&quot; : &quot;jkl&quot; &#125;&#123; &quot;_id&quot; : &quot;abc&quot; &#125; 4.Pivot Data12345678910111213141516&#123; &quot;_id&quot; : 8751, &quot;title&quot; : &quot;The Banquet&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 2 &#125;&#123; &quot;_id&quot; : 8752, &quot;title&quot; : &quot;Divine Comedy&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 1 &#125;&#123; &quot;_id&quot; : 8645, &quot;title&quot; : &quot;Eclogues&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 2 &#125;&#123; &quot;_id&quot; : 7000, &quot;title&quot; : &quot;The Odyssey&quot;, &quot;author&quot; : &quot;Homer&quot;, &quot;copies&quot; : 10 &#125;&#123; &quot;_id&quot; : 7020, &quot;title&quot; : &quot;Iliad&quot;, &quot;author&quot; : &quot;Homer&quot;, &quot;copies&quot; : 10 &#125;以下聚合操作将books 集合中的数据转化为具有按作者分组的标题db.books.aggregate( [ &#123; $group : &#123; _id : &quot;$author&quot;, books: &#123; $push: &quot;$title&quot; &#125; &#125; &#125; ])该操作返回以下文档：&#123; &quot;_id&quot; : &quot;Homer&quot;, &quot;books&quot; : [ &quot;The Odyssey&quot;, &quot;Iliad&quot; ] &#125;&#123; &quot;_id&quot; : &quot;Dante&quot;, &quot;books&quot; : [ &quot;The Banquet&quot;, &quot;Divine Comedy&quot;, &quot;Eclogues&quot; ] &#125; 分组文件author以下聚合操作使用$$ROOT 系统变量按作者对文档进行分组。生成的文件不得超过限制。 BSON Document Size:最大BSON文档大小为16兆字节。 最大文档大小有助于确保单个文档不会使用过多的RAM，或者在传输过程中使用过多的带宽。为了存储大于最大大小的文档，MongoDB提供了GridFS API。有关GridFS的更多信息，请参阅驱动程序mongofiles的文档。 1234567891011121314151617181920212223242526db.books.aggregate( [ &#123; $group : &#123; _id : &quot;$author&quot;, books: &#123; $push: &quot;$$ROOT&quot; &#125; &#125; &#125; ])result&#123; &quot;_id&quot; : &quot;Homer&quot;, &quot;books&quot; : [ &#123; &quot;_id&quot; : 7000, &quot;title&quot; : &quot;The Odyssey&quot;, &quot;author&quot; : &quot;Homer&quot;, &quot;copies&quot; : 10 &#125;, &#123; &quot;_id&quot; : 7020, &quot;title&quot; : &quot;Iliad&quot;, &quot;author&quot; : &quot;Homer&quot;, &quot;copies&quot; : 10 &#125; ]&#125;&#123; &quot;_id&quot; : &quot;Dante&quot;, &quot;books&quot; : [ &#123; &quot;_id&quot; : 8751, &quot;title&quot; : &quot;The Banquet&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 2 &#125;, &#123; &quot;_id&quot; : 8752, &quot;title&quot; : &quot;Divine Comedy&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 1 &#125;, &#123; &quot;_id&quot; : 8645, &quot;title&quot; : &quot;Eclogues&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 2 &#125; ]&#125; $unwind（统计数组的每一个值，输出以该值为维度的数据，数据变多了，其他值一样） 从输入文档解构数组字段以输出每个元素的文档。每个输出文档都是输入文档，其中数组字段的值由元素替换。 该$unwind阶段具有以下两种语法之一： 操作数是一个字段路径：要指定字段路径，请在字段名称前加上美元符号， $并用引号括起来 1&#123; $unwind: &lt;field path&gt; &#125; 操作数是一个文件： 12345678&#123; $unwind: &#123; path: &lt;field path&gt;, includeArrayIndex: &lt;string&gt;, preserveNullAndEmptyArrays: &lt;boolean&gt; &#125;&#125; 领域 类型 描述 path string 数组字段的字段路径。要指定字段路径，请在字段名称前加上美元符号，$并用引号括起来。 includeArrayIndex string 可选的。用于保存元素的数组索引的新字段的名称。该名称不能以美元符号开头$。 preserveNullAndEmptyArrays boolean 可选的。如果true，如果path为null，缺少或为空数组，则$unwind输出文档。如果false，$unwind如果path为null，缺少或空数组， 则不输出文档。默认值为false。 行为非阵列场路径版本3.2中更改：$unwind非数组操作数上的阶段不再出错。如果操作数未解析为数组但未丢失，null或空数组，$unwind则将操作数视为单个元素数组。 以前，如果字段路径指定的字段中的值 不是数组，db.collection.aggregate()则会生成错误。 缺少字段如果为输入文档中不存在的字段指定路径，或者该字段为空数组，则$unwind默认情况下会忽略输入文档，并且不会输出该输入文档的文档。 版本3.2中的新增功能：要输出缺少数组字段的文档，null或空数组，请使用该选项preserveNullAndEmptyArrays。 示例展开数组考虑inventory使用以下文档： 123456789101112&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC1&quot;, sizes: [ &quot;S&quot;, &quot;M&quot;, &quot;L&quot;] &#125;以下聚合使用该$unwind阶段为sizes数组中的每个元素输出文档：db.inventory.aggregate( [ &#123; $unwind : &quot;$sizes&quot; &#125; ] )该操作返回以下结果：每个文档都与输入文档相同，除了sizes现在包含原始sizes数组值的字段的值 。&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC1&quot;, &quot;sizes&quot; : &quot;S&quot; &#125;&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC1&quot;, &quot;sizes&quot; : &quot;M&quot; &#125;&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC1&quot;, &quot;sizes&quot; : &quot;L&quot; &#125; includeArrayIndex和preserveNullAndEmptyArrays¶版本3.2中的新功能。 集合inventory包含以下文件： 1234567891011121314151617&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC&quot;, &quot;sizes&quot;: [ &quot;S&quot;, &quot;M&quot;, &quot;L&quot;] &#125;&#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;EFG&quot;, &quot;sizes&quot; : [ ] &#125;&#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;IJK&quot;, &quot;sizes&quot;: &quot;M&quot; &#125;&#123; &quot;_id&quot; : 4, &quot;item&quot; : &quot;LMN&quot; &#125;&#123; &quot;_id&quot; : 5, &quot;item&quot; : &quot;XYZ&quot;, &quot;sizes&quot; : null &#125;以下$unwind操作是等效的，并返回sizes字段中每个元素的文档。如果sizes 字段未解析为数组但未丢失，null或空数组，$unwind则将非数组操作数视为单个元素数组。db.inventory.aggregate( [ &#123; $unwind: &quot;$sizes&quot; &#125; ] )db.inventory.aggregate( [ &#123; $unwind: &#123; path: &quot;$sizes&quot; &#125; &#125; ] )该操作返回以下文档：&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC&quot;, &quot;sizes&quot; : &quot;S&quot; &#125;&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC&quot;, &quot;sizes&quot; : &quot;M&quot; &#125;&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC&quot;, &quot;sizes&quot; : &quot;L&quot; &#125;&#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;IJK&quot;, &quot;sizes&quot; : &quot;M&quot; &#125; 以下$unwind操作使用该 includeArrayIndex选项输出数组元素的数组索引。123456789db.inventory.aggregate( [ &#123; $unwind: &#123; path: &quot;$sizes&quot;, includeArrayIndex: &quot;arrayIndex&quot; &#125; &#125; ] )该操作展开sizes数组并在新arrayIndex字段中包含数组索引的数组索引。如果该sizes 字段未解析为数组但未丢失，null或空数组，则该arrayIndex字段为null。&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC&quot;, &quot;sizes&quot; : &quot;S&quot;, &quot;arrayIndex&quot; : NumberLong(0) &#125;&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC&quot;, &quot;sizes&quot; : &quot;M&quot;, &quot;arrayIndex&quot; : NumberLong(1) &#125;&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC&quot;, &quot;sizes&quot; : &quot;L&quot;, &quot;arrayIndex&quot; : NumberLong(2) &#125;&#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;IJK&quot;, &quot;sizes&quot; : &quot;M&quot;, &quot;arrayIndex&quot; : null &#125; 以下$unwind操作使用该 preserveNullAndEmptyArrays选项在输出中包含sizes缺少字段的文档，null或空数组。12345678910111213db.inventory.aggregate( [ &#123; $unwind: &#123; path: &quot;$sizes&quot;, preserveNullAndEmptyArrays: true &#125; &#125;] )除了展开sizes元素数组或非空非数组字段的文档之外，操作还会输出sizes缺少字段的空文件或空数组，而不进行修改：&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC&quot;, &quot;sizes&quot; : &quot;S&quot; &#125;&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC&quot;, &quot;sizes&quot; : &quot;M&quot; &#125;&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC&quot;, &quot;sizes&quot; : &quot;L&quot; &#125;&#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;EFG&quot; &#125;&#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;IJK&quot;, &quot;sizes&quot; : &quot;M&quot; &#125;&#123; &quot;_id&quot; : 4, &quot;item&quot; : &quot;LMN&quot; &#125;&#123; &quot;_id&quot; : 5, &quot;item&quot; : &quot;XYZ&quot;, &quot;sizes&quot; : null &#125; $match 过滤文档以仅将符合指定条件的文档传递到下一个管道阶段。 该$match阶段具有以下原型形式： 1&#123; $match: &#123; &lt;query&gt; &#125; &#125; $match获取指定查询条件的文档。查询语法与读操作查询语法相同; 即 $match不接受原始聚合表达式。相反，使用$expr查询表达式包含聚合表达式$match。 行为Pipeline Optimization 放置$match在聚集早 管道越好。由于$match限制了聚合管道中的文档总数，因此先前的$match操作可以最大限度地减少管道的处理量。 如果您$match在管道的最开头放置一个，则查询可以利用其他任何索引db.collection.find() 或索引db.collection.findOne()。 限制该$match查询语法等同于读出操作查询语法; 即 $match不接受原始聚合表达式。要包含聚合表达式$match，请使用$expr查询表达式： 1&#123; $match: &#123; $expr: &#123; &lt;aggregation expression&gt; &#125; &#125; &#125; 不能使用$where在$match查询作为聚合管道的一部分。 您不能在 查询中使用$near或作为聚合管道的一部分。作为替代方案，您可以：$nearSphere$match 使用$geoNear舞台而不是$match舞台。 使用$geoWithin查询运营商，$center或 $centerSphere在$match阶段。 要$text在$match舞台上使用， $match舞台必须是管道的第一阶段。 视图不支持文本搜索。 示例平等匹配这些示例使用以articles下列文档命名的集合： 1234567891011121314151617181920&#123; &quot;_id&quot; : ObjectId(&quot;512bc95fe835e68f199c8686&quot;), &quot;author&quot; : &quot;dave&quot;, &quot;score&quot; : 80, &quot;views&quot; : 100 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;512bc962e835e68f199c8687&quot;), &quot;author&quot; : &quot;dave&quot;, &quot;score&quot; : 85, &quot;views&quot; : 521 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;55f5a192d4bede9ac365b257&quot;), &quot;author&quot; : &quot;ahn&quot;, &quot;score&quot; : 60, &quot;views&quot; : 1000 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;55f5a192d4bede9ac365b258&quot;), &quot;author&quot; : &quot;li&quot;, &quot;score&quot; : 55, &quot;views&quot; : 5000 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;55f5a1d3d4bede9ac365b259&quot;), &quot;author&quot; : &quot;annT&quot;, &quot;score&quot; : 60, &quot;views&quot; : 50 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;55f5a1d3d4bede9ac365b25a&quot;), &quot;author&quot; : &quot;li&quot;, &quot;score&quot; : 94, &quot;views&quot; : 999 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;55f5a1d3d4bede9ac365b25b&quot;), &quot;author&quot; : &quot;ty&quot;, &quot;score&quot; : 95, &quot;views&quot; : 1000 &#125;平等匹配以下操作用于$match执行简单的相等匹配：db.articles.aggregate( [ &#123; $match : &#123; author : &quot;dave&quot; &#125; &#125; ]);将$match选择其中的文件author 字段等于dave，并聚集返回以下内容：&#123; &quot;_id&quot; : ObjectId(&quot;512bc95fe835e68f199c8686&quot;), &quot;author&quot; : &quot;dave&quot;, &quot;score&quot; : 80, &quot;views&quot; : 100 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;512bc962e835e68f199c8687&quot;), &quot;author&quot; : &quot;dave&quot;, &quot;score&quot; : 85, &quot;views&quot; : 521 &#125; 执行计数以下示例使用$match管道运算符选择要处理的文档 ，然后将结果通过$group管道传输给管道运算符以计算文档计数： 123456789db.articles.aggregate( [ &#123; $match: &#123; $or: [ &#123; score: &#123; $gt: 70, $lt: 90 &#125; &#125;, &#123; views: &#123; $gte: 1000 &#125; &#125; ] &#125; &#125;, &#123; $group: &#123; _id: null, count: &#123; $sum: 1 &#125; &#125; &#125;] );在凝集管道，$match选择的文件，其中任一score大于70和小于90 或views大于或等于1000。然后将这些文件用管道输送$group到进行计数。聚合返回以下内容：&#123; “ _ id” ： null ， “count” ： 5 &#125; $lookup版本3.2中的新功能。 对同一 数据库中的未整数集合执行左外连接，以从“已连接”集合中过滤文档以进行处理。对于每个输入文档，该$lookup阶段添加一个新的数组字段，其元素是来自“已连接”集合的匹配文档。该$lookup阶段通过这些重塑文件到下一阶段。 语法该$lookup阶段具有以下语法： 平等匹配要在输入文档中的字段与“已加入”集合的文档中的字段之间执行相等匹配，该 $lookup阶段具有以下语法： 123456789&#123; $lookup: &#123; from: &lt;collection to join&gt;, localField: &lt;field from the input documents&gt;, foreignField: &lt;field from the documents of the &quot;from&quot; collection&gt;, as: &lt;output array field&gt; &#125;&#125; 在$lookup需要具有以下字段的文档： 领域 描述 from 指定同一数据库中的集合以执行连接。该from集合无法分片。有关详细信息，请参阅Sharded Collection Restrictions。 localField 指定输入到$lookup舞台的文档中的字段 。$lookup执行上的平等匹配localField到foreignField从的文档from 集合。如果输入文档不包含该输入文档 localField，则$lookup将该字段视为具有null用于匹配目的的值。注意如果您localField是一个数组，则可能需要$unwind在管道中添加一个 阶段。否则，之间的平等条件localField，并 foreignField为。foreignField: { $in: [localField.elem1, localField.elem2, ... ] }请参阅此页面上的示例。 foreignField 指定from 集合中文档的字段。$lookup执行上的平等匹配foreignField到localField从输入文件。如果from集合中的文档不包含foreignField，$lookup则将值视为null匹配目的。 as 指定要添加到输入文档的新数组字段的名称。新数组字段包含from集合中的匹配文档。如果输入文档中已存在指定的名称，则会覆盖现有字段 。 该操作将对应于以下伪SQL语句： 12345SELECT *, &lt;output array field&gt;FROM collectionWHERE &lt;output array field&gt; IN (SELECT * FROM &lt;collection to join&gt; WHERE &lt;foreignField&gt;= &lt;collection.localField&gt;); 请参阅以下示例： 使用$ lookup执行单一等式连接 对数组使用$ lookup 对$ mergeObjects使用$ lookup 加入条件和不相关的子查询版本3.6中的新功能。 要在两个集合之间执行不相关的子查询以及允许除单个相等匹配之外的其他连接条件，该 $lookup阶段具有以下语法： 123456789&#123; $lookup: &#123; from: &lt;collection to join&gt;, let: &#123; &lt;var_1&gt;: &lt;expression&gt;, …, &lt;var_n&gt;: &lt;expression&gt; &#125;, pipeline: [ &lt;pipeline to execute on the collection to join&gt; ], as: &lt;output array field&gt; &#125;&#125; 在$lookup需要具有以下字段的文档： 领域 描述 from 指定同一数据库中的集合以执行连接。该from集合无法分片。有关详细信息，请参阅Sharded Collection Restrictions。 let 可选的。指定要在pipeline字段阶段中使用的变量。使用变量表达式从输入到$lookup舞台的文档中访问字段。在pipeline不能直接访问输入文档字段。相反，首先定义输入文档字段的变量，然后引用中的阶段中的变量pipeline。要访问中的let变量pipeline，请使用 $expr运算符。注意该let变量是在该阶段访问 pipeline，包括额外的$lookup嵌套的阶段pipeline。 pipeline 指定要在已连接集合上运行的管道。该 pipeline决定从加入集合生成的文件。要返回所有文档，请指定一个空管道 []。在pipeline不能直接访问输入文档字段。相反，首先定义输入文档字段的变量，然后引用中的阶段中的变量pipeline。要访问中的let变量pipeline，请使用 $expr运算符。注意该let变量是在该阶段访问 pipeline，包括额外的$lookup嵌套的阶段pipeline。 as 指定要添加到输入文档的新数组字段的名称。新数组字段包含from集合中的匹配文档。如果输入文档中已存在指定的名称，则会覆盖现有字段 。 该操作将对应于以下伪SQL语句： 12345SELECT *, &lt;output array field&gt;FROM collectionWHERE &lt;output array field&gt; IN (SELECT &lt;documents as determined from the pipeline&gt; FROM &lt;collection to join&gt; WHERE &lt;pipeline&gt; ); 请参阅以下示例： 使用$ lookup指定多个连接条件 不相关的子查询 考虑视图和整理如果执行涉及多个视图的聚合（例如使用$lookup或）$graphLookup，则视图必须具有相同的排序规则。 分片收集限制在$lookup阶段，from收集不能被 分片。但是，可以对运行该aggregate()方法的集合 进行分片。也就是说，在以下内容中： 123db.collection.aggregate([ &#123; $lookup: &#123; from: &quot;fromCollection&quot;, ... &#125; &#125;]) 该collection可以分片。 在fromCollection不能分片。 因此，要将分片集合与未分片集合连接，您可以在分片集合上运行聚合并查找未整理的集合; 例如： 123db.shardedCollection.aggregate([ &#123; $lookup: &#123; from: &quot;unshardedCollection&quot;, ... &#125; &#125;]) 或者，或者要连接多个分片集合，请考虑： 修改客户端应用程序以执行手动查找，而不是使用$lookup聚合阶段。 如果可能，使用嵌入式数据模型，无需加入集合。 示例执行单个等式连接$lookuporders使用以下文档创建集合： 12345db.orders.insert([ &#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;almonds&quot;, &quot;price&quot; : 12, &quot;quantity&quot; : 2 &#125;, &#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;pecans&quot;, &quot;price&quot; : 20, &quot;quantity&quot; : 1 &#125;, &#123; &quot;_id&quot; : 3 &#125;]) inventory使用以下文档创建另一个集合： 12345678db.inventory.insert([ &#123; &quot;_id&quot; : 1, &quot;sku&quot; : &quot;almonds&quot;, description: &quot;product 1&quot;, &quot;instock&quot; : 120 &#125;, &#123; &quot;_id&quot; : 2, &quot;sku&quot; : &quot;bread&quot;, description: &quot;product 2&quot;, &quot;instock&quot; : 80 &#125;, &#123; &quot;_id&quot; : 3, &quot;sku&quot; : &quot;cashews&quot;, description: &quot;product 3&quot;, &quot;instock&quot; : 60 &#125;, &#123; &quot;_id&quot; : 4, &quot;sku&quot; : &quot;pecans&quot;, description: &quot;product 4&quot;, &quot;instock&quot; : 70 &#125;, &#123; &quot;_id&quot; : 5, &quot;sku&quot;: null, description: &quot;Incomplete&quot; &#125;, &#123; &quot;_id&quot; : 6 &#125;]) 在下面的聚合操作orders系列外，从文件orders从文件 inventory使用的字段集合item从 orders收集和sku从外地inventory 收集： 123456789101112131415161718192021222324252627282930313233343536373839db.orders.aggregate([ &#123; $lookup: &#123; from: &quot;inventory&quot;, localField: &quot;item&quot;, foreignField: &quot;sku&quot;, as: &quot;inventory_docs&quot; &#125; &#125;])该操作返回以下文档：&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;almonds&quot;, &quot;price&quot; : 12, &quot;quantity&quot; : 2, &quot;inventory_docs&quot; : [ &#123; &quot;_id&quot; : 1, &quot;sku&quot; : &quot;almonds&quot;, &quot;description&quot; : &quot;product 1&quot;, &quot;instock&quot; : 120 &#125; ]&#125;&#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;pecans&quot;, &quot;price&quot; : 20, &quot;quantity&quot; : 1, &quot;inventory_docs&quot; : [ &#123; &quot;_id&quot; : 4, &quot;sku&quot; : &quot;pecans&quot;, &quot;description&quot; : &quot;product 4&quot;, &quot;instock&quot; : 70 &#125; ]&#125;&#123; &quot;_id&quot; : 3, &quot;inventory_docs&quot; : [ &#123; &quot;_id&quot; : 5, &quot;sku&quot; : null, &quot;description&quot; : &quot;Incomplete&quot; &#125;, &#123; &quot;_id&quot; : 6 &#125; ]&#125; 该操作将对应于以下伪SQL语句： 12345SELECT *, inventory_docsFROM ordersWHERE inventory_docs IN (SELECT *FROM inventoryWHERE sku= orders.item); 使用$lookup与数组如果您localField是一个数组，并且您希望将其中的元素与foreignField单个元素进行匹配，则您需要$unwind将该数组作为聚合管道的一个阶段。 考虑一个orders包含以下文档的集合： 12&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;MON1003&quot;, &quot;price&quot; : 350, &quot;quantity&quot; : 2, &quot;specs&quot; :[ &quot;27 inch&quot;, &quot;Retina display&quot;, &quot;1920x1080&quot; ], &quot;type&quot; : &quot;Monitor&quot; &#125; 另一个集合inventory包含以下文档： 123456&#123; &quot;_id&quot; : 1, &quot;sku&quot; : &quot;MON1003&quot;, &quot;type&quot; : &quot;Monitor&quot;, &quot;instock&quot; : 120,&quot;size&quot; : &quot;27 inch&quot;, &quot;resolution&quot; : &quot;1920x1080&quot; &#125;&#123; &quot;_id&quot; : 2, &quot;sku&quot; : &quot;MON1012&quot;, &quot;type&quot; : &quot;Monitor&quot;, &quot;instock&quot; : 85,&quot;size&quot; : &quot;23 inch&quot;, &quot;resolution&quot; : &quot;1280x800&quot; &#125;&#123; &quot;_id&quot; : 3, &quot;sku&quot; : &quot;MON1031&quot;, &quot;type&quot; : &quot;Monitor&quot;, &quot;instock&quot; : 60,&quot;size&quot; : &quot;23 inch&quot;, &quot;display_type&quot; : &quot;LED&quot; &#125; 以下聚合操作对orders集合中的文档执行连接，这些文档 将specs 数组的特定元素size与inventory集合中的字段进行匹配。 1234567891011121314151617181920212223242526272829303132333435363738db.orders.aggregate([ &#123; $unwind: &quot;$specs&quot; &#125;, &#123; $lookup: &#123; from: &quot;inventory&quot;, localField: &quot;specs&quot;, foreignField: &quot;size&quot;, as: &quot;inventory_docs&quot; &#125; &#125;, &#123; $match: &#123; &quot;inventory_docs&quot;: &#123; $ne: [] &#125; &#125; &#125;])该操作返回以下文档：&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;MON1003&quot;, &quot;price&quot; : 350, &quot;quantity&quot; : 2, &quot;specs&quot; : &quot;27 inch&quot;, &quot;type&quot; : &quot;Monitor&quot;, &quot;inventory_docs&quot; : [ &#123; &quot;_id&quot; : 1, &quot;sku&quot; : &quot;MON1003&quot;, &quot;type&quot; : &quot;Monitor&quot;, &quot;instock&quot; : 120, &quot;size&quot; : &quot;27 inch&quot;, &quot;resolution&quot; : &quot;1920x1080&quot; &#125; ]&#125; 使用$lookup与$mergeObjects在版本3.6中更改： MongoDB 3.6添加了$mergeObjects运算符以将多个文档合并到单个文档中 orders使用以下文档创建集合： 1234567891011db.orders.insert([ &#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;almonds&quot;, &quot;price&quot; : 12, &quot;quantity&quot; : 2 &#125;, &#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;pecans&quot;, &quot;price&quot; : 20, &quot;quantity&quot; : 1 &#125;])db.items.insert([ &#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;almonds&quot;, description: &quot;almond clusters&quot;, &quot;instock&quot; : 120 &#125;, &#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;bread&quot;, description: &quot;raisin and nut bread&quot;, &quot;instock&quot; : 80 &#125;, &#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;pecans&quot;, description: &quot;candied pecans&quot;, &quot;instock&quot; : 60 &#125;]) 下面的操作首先使用$lookup阶段加入由两个集合item的字段，然后使用 $mergeObjects在$replaceRoot给加盟的文件从合并items和orders： 123456789101112131415161718db.orders.aggregate([ &#123; $lookup: &#123; from: &quot;items&quot;, localField: &quot;item&quot;, // field in the orders collection foreignField: &quot;item&quot;, // field in the items collection as: &quot;fromItems&quot; &#125; &#125;, &#123; $replaceRoot: &#123; newRoot: &#123; $mergeObjects: [ &#123; $arrayElemAt: [ &quot;$fromItems&quot;, 0 ] &#125;, &quot;$$ROOT&quot; ] &#125; &#125; &#125;, &#123; $project: &#123; fromItems: 0 &#125; &#125;])该操作返回以下文档：&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;almonds&quot;, &quot;description&quot; : &quot;almond clusters&quot;, &quot;instock&quot; : 120, &quot;price&quot; : 12, &quot;quantity&quot; : 2 &#125;&#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;pecans&quot;, &quot;description&quot; : &quot;candied pecans&quot;, &quot;instock&quot; : 60, &quot;price&quot; : 20, &quot;quantity&quot; : 1 &#125; 使用指定多个连接条件$lookup在版本3.6中更改： MongoDB 3.6添加了对在已加入集合上执行管道的支持，这允许指定多个连接条件以及不相关的子查询。 1234567891011121314db.orders.insert([ &#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;almonds&quot;, &quot;price&quot; : 12, &quot;ordered&quot; : 2 &#125;, &#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;pecans&quot;, &quot;price&quot; : 20, &quot;ordered&quot; : 1 &#125;, &#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;cookies&quot;, &quot;price&quot; : 10, &quot;ordered&quot; : 60 &#125;])db.warehouses.insert([ &#123; &quot;_id&quot; : 1, &quot;stock_item&quot; : &quot;almonds&quot;, warehouse: &quot;A&quot;, &quot;instock&quot; : 120 &#125;, &#123; &quot;_id&quot; : 2, &quot;stock_item&quot; : &quot;pecans&quot;, warehouse: &quot;A&quot;, &quot;instock&quot; : 80 &#125;, &#123; &quot;_id&quot; : 3, &quot;stock_item&quot; : &quot;almonds&quot;, warehouse: &quot;B&quot;, &quot;instock&quot; : 60 &#125;, &#123; &quot;_id&quot; : 4, &quot;stock_item&quot; : &quot;cookies&quot;, warehouse: &quot;B&quot;, &quot;instock&quot; : 40 &#125;, &#123; &quot;_id&quot; : 5, &quot;stock_item&quot; : &quot;cookies&quot;, warehouse: &quot;A&quot;, &quot;instock&quot; : 80 &#125;]) 以下操作将orders集合与 warehouse项目集合以及库存中的数量是否足以覆盖订购数量： 1234567891011121314151617181920212223242526272829303132db.orders.aggregate([ &#123; $lookup: &#123; from: &quot;warehouses&quot;, let: &#123; order_item: &quot;$item&quot;, order_qty: &quot;$ordered&quot; &#125;, pipeline: [ &#123; $match: &#123; $expr: &#123; $and: [ &#123; $eq: [ &quot;$stock_item&quot;, &quot;$$order_item&quot; ] &#125;, &#123; $gte: [ &quot;$instock&quot;, &quot;$$order_qty&quot; ] &#125; ] &#125; &#125; &#125;, &#123; $project: &#123; stock_item: 0, _id: 0 &#125; &#125; ], as: &quot;stockdata&quot; &#125; &#125;])该操作返回以下文档：&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;almonds&quot;, &quot;price&quot; : 12, &quot;ordered&quot; : 2, &quot;stockdata&quot; : [ &#123; &quot;warehouse&quot; : &quot;A&quot;, &quot;instock&quot; : 120 &#125;, &#123; &quot;warehouse&quot; : &quot;B&quot;, &quot;instock&quot; : 60 &#125; ] &#125;&#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;pecans&quot;, &quot;price&quot; : 20, &quot;ordered&quot; : 1, &quot;stockdata&quot; : [ &#123; &quot;warehouse&quot; : &quot;A&quot;, &quot;instock&quot; : 80 &#125; ] &#125;&#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;cookies&quot;, &quot;price&quot; : 10, &quot;ordered&quot; : 60, &quot;stockdata&quot; : [ &#123; &quot;warehouse&quot; : &quot;A&quot;, &quot;instock&quot; : 80 &#125; ] &#125; 该操作将对应于以下伪SQL语句： 123456SELECT *, stockdataFROM ordersWHERE stockdata IN (SELECT warehouse, instock FROM warehouses WHERE stock_item= orders.item AND instock &gt;= orders.ordered ); 不相关的子查询在版本3.6中更改： MongoDB 3.6添加了对在已加入集合上执行管道的支持，这允许指定多个连接条件以及不相关的子查询。 absences使用以下文档创建集合： 12345678910111213db.absences.insert([ &#123; &quot;_id&quot; : 1, &quot;student&quot; : &quot;Ann Aardvark&quot;, sickdays: [ new Date (&quot;2018-05-01&quot;),new Date (&quot;2018-08-23&quot;) ] &#125;, &#123; &quot;_id&quot; : 2, &quot;student&quot; : &quot;Zoe Zebra&quot;, sickdays: [ new Date (&quot;2018-02-01&quot;),new Date (&quot;2018-05-23&quot;) ] &#125;,])db.holidays.insert([ &#123; &quot;_id&quot; : 1, year: 2018, name: &quot;New Years&quot;, date: new Date(&quot;2018-01-01&quot;) &#125;, &#123; &quot;_id&quot; : 2, year: 2018, name: &quot;Pi Day&quot;, date: new Date(&quot;2018-03-14&quot;) &#125;, &#123; &quot;_id&quot; : 3, year: 2018, name: &quot;Ice Cream Day&quot;, date: new Date(&quot;2018-07-15&quot;) &#125;, &#123; &quot;_id&quot; : 4, year: 2017, name: &quot;New Years&quot;, date: new Date(&quot;2017-01-01&quot;) &#125;, &#123; &quot;_id&quot; : 5, year: 2017, name: &quot;Ice Cream Day&quot;, date: new Date(&quot;2017-07-16&quot;) &#125;]) 以下操作将absences集合与集合中的2018个假日信息结合在一起holidays： 12345678910111213141516171819202122db.absences.aggregate([ &#123; $lookup: &#123; from: &quot;holidays&quot;, pipeline: [ &#123; $match: &#123; year: 2018 &#125; &#125;, &#123; $project: &#123; _id: 0, date: &#123; name: &quot;$name&quot;, date: &quot;$date&quot; &#125; &#125; &#125;, &#123; $replaceRoot: &#123; newRoot: &quot;$date&quot; &#125; &#125; ], as: &quot;holidays&quot; &#125; &#125;])该操作返回以下内容：&#123; &quot;_id&quot; : 1, &quot;student&quot; : &quot;Ann Aardvark&quot;, &quot;sickdays&quot; : [ ISODate(&quot;2018-05-01T00:00:00Z&quot;), ISODate(&quot;2018-08-23T00:00:00Z&quot;) ], &quot;holidays&quot; : [ &#123; &quot;name&quot; : &quot;New Years&quot;, &quot;date&quot; : ISODate(&quot;2018-01-01T00:00:00Z&quot;) &#125;, &#123; &quot;name&quot; : &quot;Pi Day&quot;, &quot;date&quot; : ISODate(&quot;2018-03-14T00:00:00Z&quot;) &#125;, &#123; &quot;name&quot; : &quot;Ice Cream Day&quot;, &quot;date&quot; : ISODate(&quot;2018-07-15T00:00:00Z&quot;) &#125; ] &#125;&#123; &quot;_id&quot; : 2, &quot;student&quot; : &quot;Zoe Zebra&quot;, &quot;sickdays&quot; : [ ISODate(&quot;2018-02-01T00:00:00Z&quot;), ISODate(&quot;2018-05-23T00:00:00Z&quot;) ], &quot;holidays&quot; : [ &#123; &quot;name&quot; : &quot;New Years&quot;, &quot;date&quot; : ISODate(&quot;2018-01-01T00:00:00Z&quot;) &#125;, &#123; &quot;name&quot; : &quot;Pi Day&quot;, &quot;date&quot; : ISODate(&quot;2018-03-14T00:00:00Z&quot;) &#125;, &#123; &quot;name&quot; : &quot;Ice Cream Day&quot;, &quot;date&quot; : ISODate(&quot;2018-07-15T00:00:00Z&quot;) &#125; ] &#125; 该操作将对应于以下伪SQL语句： 12345SELECT *, holidaysFROM absencesWHERE holidays IN (SELECT name, date FROM holidays WHERE year = 2018); 参考文档 mongodb文档]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>aggregate</tag>
      </tags>
  </entry>
</search>
