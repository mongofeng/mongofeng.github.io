<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[函数指令 (Function Directives)]]></title>
    <url>%2F2019%2F06%2F05%2FFunction-Directives%2F</url>
    <content type="text"><![CDATA[Sass 支持自定义函数，并能在任何值或脚本上下文中使用。例如 12345678$grid-width: 40px; $gutter-width: 10px;@function grid-width($n) &#123; @return $n * $grid-width + ($n - 1) * $gutter-width;&#125;#sidebar &#123; width: grid-width(5); &#125; 就变成了: 12#sidebar &#123; width: 240px; &#125; 正如你看到的，函数可以访问任何全局定义的变量，以及接受参数，就像一个混入（mixin）。函数可以包含语句，并且你必须调用@return来设置函数的返回值。 与混入（mixin）一样，你可以使用关键字参数来调用Sass定义的函数。在上面的例子中，我们可以这样调用函数： 1#sidebar &#123; width: grid-width($n: 5); &#125; 建议您在函数前加上前缀，以避免命名冲突，其他人阅读样式表的时候也会知道它们不是 Sass 或者 CSS 的自带功能。例如，如果您在ACME公司工作，你可以给上面的函数取名为-acme-grid-width。 用户自定义的函数也支持可变参数，方式和混入（mixin）是相同的。 由于历史的原因，函数名（和所有其他Sass标识符）中连字符和下划线可以互换。例如，如果你定义了一个名为grid-width的函数，你可以通过grid_width调用它，反之亦然。 mixins 和 function function只能返回值 mixins可以返回key/value, 或者是整个类的样式, 可以接收外来样式的嵌入]]></content>
      <categories>
        <category>sass学习手记</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[混入指令 (Mixin Directives)]]></title>
    <url>%2F2019%2F06%2F05%2FMixins-Directives%2F</url>
    <content type="text"><![CDATA[混入(mixin)允许您定义可以在整个样式表中重复使用的样式，而避免了使用无语意的类（class），比如 .float-left。混入(mixin)还可以包含所有的CSS规则，以及任何其他在Sass文档中被允许使用的东西。他们甚至可以带arguments，引入变量，只需少量的混入(mixin)代码就能输出多样化的样式。 定义一个混入(mixin):@mixin（Defining a Mixin: @mixin）混入(mixin)通过 @mixin 指令定义。在它后面跟混入的名称和任选的arguments（参数），以及混入的内容块。例如，large-text混入定义如下： 12345678@mixin large-text &#123; font: &#123; family: Arial; size: 20px; weight: bold; &#125; color: #ff0000;&#125; 混入也可以包含选择器和属性的混合体，选择器中甚至可以包含parent references（父选择器）。 例如： 1234567891011@mixin clearfix &#123; display: inline-block; &amp;:after &#123; content: &quot;.&quot;; display: block; height: 0; clear: both; visibility: hidden; &#125; * html &amp; &#123; height: 1px &#125;&#125; 由于历史原因，混入（mixin）的名字（和所有其他 Sass 标识符）可以互换连字符和下划线。例如，如果你定义了一个名为add-column的混入，你可以把它作为add_column，反之亦然。 引用混合样式:@include （Including a Mixin: @include）使用 @include 指令可以将混入（mixin）引入到文档中。这需要一个混入的名称和可选的参数传递给它，并包括由混入定义的当前规则的样式。 例如： 12345.page-title &#123; @include large-text; padding: 4px; margin-top: 10px;&#125; 编译为： 1234567.page-title &#123; font-family: Arial; font-size: 20px; font-weight: bold; color: #ff0000; padding: 4px; margin-top: 10px; &#125; 混入（mixin）也可以包含在任何规则的外（即，在文档的根）,只要它们不直接定义的任何属性或使用任何父选择器引用。例如： 12345678@mixin silly-links &#123; a &#123; color: blue; background-color: red; &#125;&#125;@include silly-links; 编译为： 123a &#123; color: blue; background-color: red; &#125; 混入（mixin）定义也可以包含其他的混入。例如： 1234567@mixin compound &#123; @include highlighted-background; @include header-text;&#125;@mixin highlighted-background &#123; background-color: #fc0; &#125;@mixin header-text &#123; font-size: 20px; &#125; 混入可以包含自己。这行为不同于 Sass 3.3 之前的版本，以前混入递归是被禁止的。 只定义后代选择器的混入可以安全地混入到文件的最顶层。 参数 (Arguments)混入（mixin）可以用 SassScript 值作为参数，给定的参数被包括在混入（mixin）中并且作为为变量提供给混入（mixin）。 当定义一个混入（mixin）的时候，参数被作为变量名，写到混入（mixin）名字后面的括号内，多个参数可以用逗号分隔。然后，当调用混入的时候，值通过对应的参数顺序被传递。 例如： 123456789@mixin sexy-border($color, $width) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border(blue, 1in); &#125; 编译为： 1234p &#123; border-color: blue; border-width: 1in; border-style: dashed; &#125; 混入（mixin）也可以使用普通的变量赋值语法为参数指定默认值。然后，当调用混入的时候，如果没有给参数赋值，则自动会使用默认值代替。 例如： 123456789@mixin sexy-border($color, $width: 1in) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border(blue); &#125;h1 &#123; @include sexy-border(blue, 2in); &#125; 编译为： 123456789p &#123; border-color: blue; border-width: 1in; border-style: dashed; &#125;h1 &#123; border-color: blue; border-width: 2in; border-style: dashed; &#125; 关键字参数 (Keyword Arguments)混入（mixin）在引入（@include指令）的时候也可以使用明确的关键字参数。例如，上面的例子可以写成： 12p &#123; @include sexy-border($color: blue); &#125; h1 &#123; @include sexy-border($color: blue, $width: 2in); &#125; 虽然这是不够简明，但是它可以使样式表更容易阅读。它给函数呈现了更加灵活的接口，它使多参数的混入更加容易调用。 命名的参数可以按任何顺序进行传递，有默认值的参数可以省略。由于命名参数是变量名，下划线和连字符可以互换使用。 可变参数 (Variable Arguments)有时，不能确定一个混入（mixin）或者一个函数（function）使用多少个参数。例如，用于创建盒子阴影（box-shadow）的一个混入（mixin）可以采取任何数量的box-shadow作为参数。对于这些情况，Sass支持”可变参数”,参数在声明混入（mixin）或函数（function）结束的地方，所有剩余的参数打包成一个列表（list）。参数看起来就像普通参数一样，但后面跟随着...。例如： 123456789@mixin box-shadow($shadows...) &#123; -moz-box-shadow: $shadows; -webkit-box-shadow: $shadows; box-shadow: $shadows;&#125;.shadows &#123; @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);&#125; 编译为： 12345.shadows &#123; -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;&#125; 可变参数可以包含任何关键字参数传递给混入（mixin）或者函数（function）。这些可以使用keywords($args)函数 来访问，返回一个map，参数名称字符串（无$）和值的键值对。 可变参数，也可以在调用（@include指令）一个混入（mixin）时使用。使用相同的语法，你可以扩展值的列表（list），以便每个值作为单独的参数传入，或扩展值的map，以使每个键值对作为一个关键字参数处理。例如： 123456789101112131415@mixin colors($text, $background, $border) &#123; color: $text; background-color: $background; border-color: $border;&#125;$values: #ff0000, #00ff00, #0000ff; .primary &#123; @include colors($values...);&#125;$value-map: (text: #00ff00, background: #0000ff, border: #ff0000); .secondary &#123; @include colors($value-map...);&#125; 编译为： 1234567891011.primary &#123; color: #ff0000; background-color: #00ff00; border-color: #0000ff;&#125;.secondary &#123; color: #00ff00; background-color: #0000ff; border-color: #ff0000;&#125; 你可以同时传递一个列表（list）和一个map参数，只要列表（list）在map上之前，比如@include colors($values..., $map...)。 您可以使用可变参数来包装一个混入（mixin）并且添加额外的样式，而不改变混入（mixin）的参数签名。如果你这样做，关键字参数将通过包装的混入（mixin）直接传递。例如： 123456789@mixin wrapped-stylish-mixin($args...) &#123; font-weight: bold; @include stylish-mixin($args...);&#125;.stylish &#123; // The $width argument will get passed on to &quot;stylish-mixin&quot; as a keyword @include wrapped-stylish-mixin(#00ff00, $width: 100px);&#125; 传递内容块到混入(Passing Content Blocks to a Mixin)样式内容块可以传递到混入（mixin）包含样式的位置。样式内容块将出现在混入内的任何 @content 指令的位置。这使得可以定义抽象 关联到选择器和指令的解析。 例如： 12345678910@mixin apply-to-ie6-only &#123; * html &#123; @content; &#125;&#125;@include apply-to-ie6-only &#123; #logo &#123; background-image: url(/logo.gif); &#125;&#125; 生成: 123* html #logo &#123; background-image: url(/logo.gif);&#125; 同样的混入（mixin）可以在.sass 简写语法（@mixin 可以用 = 表示，而 @include 可以用 + 表示）来完成： 1234567=apply-to-ie6-only * html @content+apply-to-ie6-only #logo background-image: url(/logo.gif) 注意： 当@content指令指定多次或在一个循环中指定的时候，样式块将在每次调用中被复制并引用。 变量的作用域和内容块（Variable Scope and Content Blocks）传递给混入（mixin）的内容块在其被定义的作用域中进行运算，而不是混入（mixin）的作用域。这意味着混入（mixin）的局部变量不能传递给样式块使用，并且变量将解析为全局值： 123456789$color: white; @mixin colors($color: blue) &#123; background-color: $color; @content; border-color: $color;&#125;.colors &#123; @include colors &#123; color: $color; &#125;&#125; 编译为: 12345.colors &#123; background-color: blue; color: white; border-color: blue;&#125; 另外，这清楚地表明，变量和传递到块中使用的混入，指向块定义的周围其他样式。例如： 1234567#sidebar &#123; $sidebar-width: 300px; width: $sidebar-width; @include smartphone &#123; width: $sidebar-width / 3; &#125;&#125;]]></content>
      <categories>
        <category>sass学习手记</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SassScript]]></title>
    <url>%2F2019%2F06%2F05%2FSassScript%2F</url>
    <content type="text"><![CDATA[在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。 SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。 通过 interpolation，SassScript 甚至可以生成选择器或属性名，这一点对编写 mixin 有很大帮助。 1. 变量 $ (Variables: $)SassScript 最普遍的用法就是变量，变量以美元符号开头，赋值方法与 CSS 属性的写法一样： 1$width: 5em; 直接使用即调用变量： 123#main &#123; width: $width;&#125; 变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 !global 声明： 12345678#main &#123; $width: 5em !global; width: $width;&#125;#sidebar &#123; width: $width;&#125; 编译为 1234567#main &#123; width: 5em;&#125;#sidebar &#123; width: 5em;&#125; 2. 数据类型 (Data Types)SassScript 支持 6 种主要的数据类型： 数字，1, 2, 13, 10px 字符串，有引号字符串与无引号字符串，&quot;foo&quot;, &#39;bar&#39;, baz 颜色，blue, #04a3f9, rgba(255,0,0,0.5) 布尔型，true, false 空值，null 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2) SassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 !important 声明。然而Sass 不会特殊对待这些属性值，一律视为无引号字符串。 2.1. 字符串 (Strings)SassScript 支持 CSS 的两种字符串类型：有引号字符串 (quoted strings)，如 &quot;Lucida Grande&quot; &#39;http://sass-lang.com&#39;；与无引号字符串 (unquoted strings)，如 sans-serif bold，在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 #{}(interpolation) 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名： 123456@mixin firefox-message($selector) &#123; body.firefox #&#123;$selector&#125;:before &#123; content: &quot;Hi, Firefox users!&quot;; &#125;&#125;@include firefox-message(&quot;.header&quot;); 编译为 12body.firefox .header:before &#123; content: &quot;Hi, Firefox users!&quot;; &#125; 2.2. 数组 (Lists)数组 (lists) 指 Sass 如何处理 CSS 中 margin: 10px 15px 0 0 或者 font-face: Helvetica, Arial, sans-serif 这样通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组 —— 只包含一个值的数组。 数组本身没有太多功能，但 Sass list functions 赋予了数组更多新功能：nth 函数可以直接访问数组中的某一项；join 函数可以将多个数组连接在一起；append 函数可以在数组中添加新值；而 @each 指令能够遍历数组中的每一项。 数组中可以包含子数组，比如 1px 2px, 5px 6px 是包含 1px 2px 与 5px 6px 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 (1px 2px) (5px 6px)。变化是，之前的 1px 2px, 5px 6px 使用逗号分割了两个子数组 (comma-separated)，而 (1px 2px) (5px 6px) 则使用空格分割(space-separated)。 当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 (1px 2px) (5px 6px) 与 1px 2px, 5px 6px在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。 用 () 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 font-family: () Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 1px 2px () 3px 或 1px 2px null 3px。 基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 (1,)表示只包含 1 的数组，而 (1 2 3,) 表示包含 1 2 3 这个以空格分隔的数组的数组。 2.3.MapsMaps代表一个键和值对集合，其中键用于查找值。他们可以很容易地将值收集到命名组中，并且可以动态地访问这些组。在CSS中你找不到和他们类似的值，虽然他们的语法类似于媒体查询表达式： 1$map: (key1: value1, key2: value2, key3: value3); 和列表（Lists）不同，Maps必须始终使用括号括起来，并且必须用逗号分隔。Maps中的键和值可以是任意的SassScript对象。一个Maps可能只有一个值与给定的键关联（尽管该值可以是一个列表）。一个给定的值可能与许多键关联。 和列表（Lists）类似，Maps的主要操作使用的是 SassScript 函数。map-get函数用于查找map中的值，map-merge函数用于添加值到map中的值， @each 指令可以用来为 map 中的每个键值对添加样式。map中键值对的顺序和map创建时始终相同。 Maps还可以用于任何列表（Lists）能做的事情。当用于一个列表函数时，map被视为键值对列表。例如，(key1: value1, key2: value2)被用于列表函数时，将被视为嵌套列表key1 value1, key2 value2。列表不能被视为maps，不过，空列表除外。 ()表示一个键/值对都没有的map,也可以被视为一个没有元素的列表。 需要注意的是 map 的建（keys）可以是任何 Sass 数据类型（甚至是另一个map），并且声明map的语法允许是任意的SassScript表达式，这个表达式将被评估为一个值以确定建（keys）。 Maps不能转换为纯CSS。作为变量的值或参数传递给CSS函数将会导致错误。使用inspect($value)函数以产生输出字符串，这对于调试 maps 非常有用。 2.4.颜色（Colors）任何CSS颜色表达式返回SassScript颜色值。这其中包括了大量的命名的颜色，这些名字字符串不区别带不带引号。 在压缩输出模式，Sass 将输出CSS简短的颜色表示法。例如，在压缩模式下 #FF0000 将输出为red，但是blanchedalmond将输出为 #FFEBCD。 一个用户遇到的常见问题是在其它输出模式中Sass喜欢输出与命名的颜色相同的格式，当压缩的时候，插值到选择器的颜色变得无效语法。为了避免这种情况，如果他们是为了在选择施工中使用，总是给命名的颜色。 3. 运算 (Operations)所有数据类型均支持相等运算 1== 或 1!= ，此外，每种数据类型也有其各自支持的运算方式。 3.1. 数字运算 (Number Operations)SassScript 支持数字的加减乘除、取整等运算 (+, -, *, /, %)，如果必要会在不同单位间转换值。 123p &#123; width: 1in + 8pt;&#125; 编译为 12p &#123; width: 1.111in; &#125; 关系运算 &lt;, &gt;, &lt;=, &gt;= 也可用于数字运算，相等运算 ==, != 可用于所有数据类型。 3.1.1. 除法运算 / (Division and /)/ 在 CSS 中通常起到分隔数字的用途，SassScript 作为 CSS 语言的拓展当然也支持这个功能，同时也赋予了 / 除法运算的功能。也就是说，如果 / 在 SassScript 中把两个数字分隔，编译后的 CSS 文件中也是同样的作用。 以下三种情况 / 将被视为除法运算符号： 如果值，或值的一部分，是变量或者函数的返回值 如果值被圆括号包裹 如果值是算数表达式的一部分 12345678p &#123; font: 10px/8px; // Plain CSS, no division $width: 1000px; width: $width/2; // Uses a variable, does division width: round(1.5)/2; // Uses a function, does division height: (500px/2); // Uses parentheses, does division margin-left: 5px + 8px/2px; // Uses +, does division&#125; 编译为 12345p &#123; font: 10px/8px; width: 500px; height: 250px; margin-left: 9px; &#125; 如果需要使用变量，同时又要确保 / 不做除法运算而是完整地编译到 CSS 文件中，只需要用 #{} 插值语句将变量包裹。 12345p &#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;&#125; 编译为 12p &#123; font: 12px/30px; &#125; 3.2. 颜色值运算 (Color Operations)颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值： 123p &#123; color: #010203 + #040506;&#125; 计算 01 + 04 = 05 02 + 05 = 07 03 + 06 = 09，然后编译为 12p &#123; color: #050709; &#125; 使用 color functions 比计算颜色值更方便一些。 数字与颜色值之间也可以进行算数运算，同样也是分段计算的，比如 123p &#123; color: #010203 * 2;&#125; 计算 01 * 2 = 02 02 * 2 = 04 03 * 2 = 06，然后编译为 12p &#123; color: #020406; &#125; 需要注意的是，如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。 123p &#123; color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);&#125; 编译为 12p &#123; color: rgba(255, 255, 0, 0.75); &#125; 颜色值的 alpha channel 可以通过 opacify 或 transparentize 两个函数进行调整。 12345$translucent-red: rgba(255, 0, 0, 0.5);p &#123; color: opacify($translucent-red, 0.3); background-color: transparentize($translucent-red, 0.25);&#125; 编译为 123p &#123; color: rgba(255, 0, 0, 0.8); background-color: rgba(255, 0, 0, 0.25); &#125; IE 滤镜要求所有的颜色值包含 alpha 层，而且格式必须固定 #AABBCCDD，使用 ie_hex_str 函数可以很容易地将颜色转化为 IE 滤镜要求的格式。 12345$translucent-red: rgba(255, 0, 0, 0.5);$green: #00ff00;div &#123; filter: progid:DXImageTransform.Microsoft.gradient(enabled=&apos;false&apos;, startColorstr=&apos;#&#123;ie-hex-str($green)&#125;&apos;, endColorstr=&apos;#&#123;ie-hex-str($translucent-red)&#125;&apos;);&#125; 编译为 123div &#123; filter: progid:DXImageTransform.Microsoft.gradient(enabled=&apos;false&apos;, startColorstr=#FF00FF00, endColorstr=#80FF0000);&#125; 3.3. 字符串运算 (String Operations)+ 可用于连接字符串 123p &#123; cursor: e + -resize;&#125; 编译为 12p &#123; cursor: e-resize; &#125; 注意，如果有引号字符串（位于 + 左侧）连接无引号字符串，运算结果是有引号的，相反，无引号字符串（位于 + 左侧）连接有引号字符串，运算结果则没有引号。 1234p:before &#123; content: &quot;Foo &quot; + Bar; font-family: sans- + &quot;serif&quot;;&#125; 编译为 123p:before &#123; content: &quot;Foo Bar&quot;; font-family: sans-serif; &#125; 运算表达式与其他值连用时，用空格做连接符： 123p &#123; margin: 3px + 4px auto;&#125; 编译为 12p &#123; margin: 7px auto; &#125; 在有引号的文本字符串中使用 #{} 插值语句可以添加动态的值： 123p:before &#123; content: &quot;I ate #&#123;5 + 10&#125; pies!&quot;;&#125; 编译为 12p:before &#123; content: &quot;I ate 15 pies!&quot;; &#125; 空的值被视作插入了空字符串： 1234$value: null;p:before &#123; content: &quot;I ate #&#123;$value&#125; pies!&quot;;&#125; 编译为 12p:before &#123; content: &quot;I ate pies!&quot;; &#125; 3.4. 布尔运算 (Boolean Operations)SassScript 支持布尔型的 and or 以及 not 运算。 3.5. 数组运算 (List Operations)数组不支持任何运算方式，只能使用 list functions 控制。 4. 圆括号 (Parentheses)圆括号可以用来影响运算的顺序： 123p &#123; width: 1em + (2em * 3);&#125; 编译为 12p &#123; width: 7em; &#125; 5.函数 (Functions)SassScript定义了一些有用的函数， 这些函数可以像普通 CSS 函数语法一样调用： 123p &#123; color: hsl(0, 100%, 50%);&#125; 编译为： 12p &#123; color: #ff0000; &#125; 可用函数的完整列表，请参阅这张页面。 5.1关键词参数 (Keyword Arguments)Sass 函数允许指定明确的关键词参数 (keyword arguments) 进行调用。 上面的例子也可以改写成： 123p &#123; color: hsl($hue: 0, $saturation: 100%, $lightness: 50%);&#125; 虽然不够简明，但可以让Sass代码阅读起来更加方便。 关键词参数让函数具有更灵活的接口， 即便参数众多，也不会让使用变得困难。 命名参数（named arguments）可以以任意顺序传入，并且，具有默认值的参数可以省略掉。 由于命名参数也是变量名称，因此，下划线、短横线可以互换使用。 完整的 Sass 函数列表和它们的参数名称，以及在 Ruby 里如何定义你自己的函数的步骤，请见 Sass::Script::Functions。 6.插值：#{}（Interpolation: #{}）您还可以通过 #{} 插值语法在选择器和属性名中使用 SassScript 变量： 12345$name: foo; $attr: border;p.#&#123;$name&#125; &#123; #&#123;$attr&#125;-color: blue;&#125; 编译为： 12p.foo &#123; border-color: blue; &#125; 它也可以使用#{}插值语句把 SassScript 插入到属性值中。在大多数情况下，这种做可能还不如使用直接变量来的方便，但使用 #{}意味着靠近它的运算符都将被视为纯CSS（愚人码头注：可以避免各种运算）。 例如： 12345p &#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;&#125; 编译为： 12p &#123; font: 12px/30px; &#125; 7.SassScript中的&amp;（&amp; in SassScript）就像当它在选择器中使用一样，SassScript中的&amp;指向当前父选择器。下面是一个逗号分隔的列表（list）中包含一个空格的分隔列表（list）。例如： 123.foo.bar .baz.bang, .bip.qux &#123; $selector: &amp;;&#125; $selector的值是现在 ((&quot;.foo.bar&quot; &quot;.baz.bang&quot;), &quot;.bip.qux&quot;)。这个混合选择器在这里加了引号，以表明他们是字符串，但在现实中，他们将不带引号的。即使选择器不包含逗号或空格，&amp;总会有两个嵌套层次，因此它可以保证访问一致性。 如果没有父选择器，&amp;的值将是空。这意味着你可以在一个mixin中使用它来检测父选择是否存在： 1234567891011@mixin does-parent-exist &#123; @if &amp; &#123; &amp;:hover &#123; color: red; &#125; &#125; @else &#123; a &#123; color: red; &#125; &#125;&#125; 变量默认: !default （Variable Defaults: !default）如果分配给变量的值后面添加了!default标志 ，这意味着该变量如果已经赋值，那么它不会被重新赋值，但是，如果它尚未赋值，那么它会被赋予新的给定值。 例如: 12345678$content: &quot;First content&quot;; $content: &quot;Second content?&quot; !default;$new_content: &quot;First time reference&quot; !default;#main &#123; content: $content; new-content: $new_content;&#125; 编译为： 123#main &#123; content: &quot;First content&quot;; new-content: &quot;First time reference&quot;; &#125; 通过!default赋值的时候，如果变量是 null 值时，将视为未赋值（愚人码头注：所以下面的$content值为 “Non-null content”）： 123456$content: null; $content: &quot;Non-null content&quot; !default;#main &#123; content: $content;&#125; 编译为： 12#main &#123; content: &quot;Non-null content&quot;; &#125;]]></content>
      <categories>
        <category>sass学习手记</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS扩展 (CSS Extensions)]]></title>
    <url>%2F2019%2F06%2F05%2FCSS-Extensions%2F</url>
    <content type="text"><![CDATA[1. 嵌套规则 (Nested Rules)Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器，例如： 123456789#main p &#123; color: #00ff00; width: 97%; .redbox &#123; background-color: #ff0000; color: #000000; &#125;&#125; 编译为 123456#main p &#123; color: #00ff00; width: 97%; &#125; #main p .redbox &#123; background-color: #ff0000; color: #000000; &#125; 嵌套功能避免了重复输入父选择器，而且令复杂的 CSS 结构更易于管理： 12345678910#main &#123; width: 97%; p, div &#123; font-size: 2em; a &#123; font-weight: bold; &#125; &#125; pre &#123; font-size: 3em; &#125;&#125; 编译为 12345678#main &#123; width: 97%; &#125; #main p, #main div &#123; font-size: 2em; &#125; #main p a, #main div a &#123; font-weight: bold; &#125; #main pre &#123; font-size: 3em; &#125; 2. 父选择器 &amp; (Referencing Parent Selectors: &amp;)在嵌套 CSS 规则时，有时也需要直接使用嵌套外层的父选择器，例如，当给某个元素设定 hover 样式时，或者当 body 元素有某个 classname 时，可以用 &amp; 代表嵌套规则外层的父选择器。 123456a &#123; font-weight: bold; text-decoration: none; &amp;:hover &#123; text-decoration: underline; &#125; body.firefox &amp; &#123; font-weight: normal; &#125;&#125; 编译为 1234567a &#123; font-weight: bold; text-decoration: none; &#125; a:hover &#123; text-decoration: underline; &#125; body.firefox a &#123; font-weight: normal; &#125; 编译后的 CSS 文件中 &amp; 将被替换成嵌套外层的父选择器，如果含有多层嵌套，最外层的父选择器会一层一层向下传递： 1234567#main &#123; color: black; a &#123; font-weight: bold; &amp;:hover &#123; color: red; &#125; &#125;&#125; 编译为 123456#main &#123; color: black; &#125; #main a &#123; font-weight: bold; &#125; #main a:hover &#123; color: red; &#125; &amp; 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器，例如 1234#main &#123; color: black; &amp;-sidebar &#123; border: 1px solid; &#125;&#125; 编译为 1234#main &#123; color: black; &#125; #main-sidebar &#123; border: 1px solid; &#125; 当父选择器含有不合适的后缀时，Sass 将会报错。 3. 属性嵌套 (Nested Properties)有些 CSS 属性遵循相同的命名空间 (namespace)，比如 font-family, font-size, font-weight 都以 font 作为属性的命名空间。为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中，例如： 1234567.funky &#123; font: &#123; family: fantasy; size: 30em; weight: bold; &#125;&#125; 编译为 1234.funky &#123; font-family: fantasy; font-size: 30em; font-weight: bold; &#125; 命名空间也可以包含自己的属性值，例如： 123456.funky &#123; font: 20px/24px &#123; family: fantasy; weight: bold; &#125;&#125; 编译为 1234.funky &#123; font: 20px/24px; font-family: fantasy; font-weight: bold; &#125; 4. 占位符选择器 %foo (Placeholder Selectors: %foo)Sass 额外提供了一种特殊类型的选择器：占位符选择器 (placeholder selector)。与常用的 id 与 class 选择器写法相似，只是 # 或 .替换成了 %。必须通过 @extend 指令调用，更多介绍请查阅 @extend-Only Selectors。 当占位符选择器单独使用时（未通过 @extend 调用），不会编译到 CSS 文件中。 5. 注释 /* */ 与 // (Comments: /* */ and //)Sass 支持标准的 CSS 多行注释 /* */，以及单行注释 //，前者会 被完整输出到编译后的 CSS 文件中，而后者则不会，例如： 12345678910/* This comment is * several lines long. * since it uses the CSS comment syntax, * it will appear in the CSS output. */body &#123; color: black; &#125;// These comments are only one line long each.// They won&apos;t appear in the CSS output,// since they use the single-line comment syntax.a &#123; color: green; &#125; 编译为 123456789/* This comment is * several lines long. * since it uses the CSS comment syntax, * it will appear in the CSS output. */body &#123; color: black; &#125;a &#123; color: green; &#125; 将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。 插值语句 (interpolation) 也可写进多行注释中输出变量值： 12$version: &quot;1.2.3&quot;;/* This CSS is generated by My Snazzy Framework version #&#123;$version&#125;. */ 编译为 1/* This CSS is generated by My Snazzy Framework version 1.2.3. */]]></content>
      <categories>
        <category>sass学习手记</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[控制指令和表达式（Control Directives & Expressions）]]></title>
    <url>%2F2019%2F06%2F03%2FControl-Directives%2F</url>
    <content type="text"><![CDATA[SassScript支持一些基本控制指令和表达式，比如仅在在某些条件下包含样式，或者包括相同的样式几次变化。 注意： 控制指令是一项高级功能，日常编写过程中并不常用到，主要在 mixins（混合）指令中使用，尤其是像Compass这样的库。 1.if()内置的if()函数可让您在一个条件处理分支并返回两种可能结果。它可以在任何脚本上下文中使用。if函数只判断相对应的一个参数并且返回 – 这使您可以引用已经定义的或者可以计算的变量，否则将导致错误（例如，除以零）。 12if(true, 1px, 2px) =&gt; 1pxif(false, 1px, 2px) =&gt; 2px 2.@if@if 指令需要一个SassScript表达和嵌套在它下面要使用的样式，如果表达式返回值不为 false 或者 null ，那么后面花括号中的内容就会返回： 12345p &#123; @if 1 + 1 == 2 &#123; border: 1px solid; &#125; @if 5 &lt; 3 &#123; border: 2px dotted; &#125; @if null &#123; border: 3px double; &#125;&#125; 编译为： 12p &#123; border: 1px solid; &#125; @if 语句后面可以跟多个@else if语句和一个 @else 语句。 如果@if语句失败，Sass 将逐条尝试@else if 语句，直到有一个成功，或如果全部失败，那么会执行@else语句。 例如： 123456789101112$type: monster; p &#123; @if $type == ocean &#123; color: blue; &#125; @else if $type == matador &#123; color: red; &#125; @else if $type == monster &#123; color: green; &#125; @else &#123; color: black; &#125;&#125; 编译为： 12p &#123; color: green; &#125; 3.@for@for指令重复输出一组样式。对于每次重复，计数器变量用于调整输出结果。该指令有两种形式：@for $var from &lt;start&gt; through &lt;end&gt; 和 @for $var from &lt;start&gt; to &lt;end&gt;。注意关键字through 和 to的区别。$var可以是任何变量名，比如$i;&lt;start&gt; 和 &lt;end&gt;是应该返回整数的SassScript表达式。当&lt;start&gt;比&lt;end&gt;大的时候，计数器将递减，而不是增量。 @for语句将设置$var为指定的范围内每个连续的数值，并且每一次输出的嵌套样式中使用$var的值。对于from ... through的形式，范围包括&lt;start&gt;和&lt;end&gt;的值，但from ... to的形式从&lt;start&gt;开始运行，但不包括&lt;end&gt;的值。使用through语法， 1234567@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125;@for $i from 1 to 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125; 编译为： 1234567891011.item-1 &#123; width: 2em; &#125;.item-2 &#123; width: 4em; &#125;.item-3 &#123; width: 6em; &#125; .item-1 &#123; width: 2em; &#125;.item-2 &#123; width: 4em; &#125; 4.@each@each指令通常格式是@each $var in &lt;list or map&gt;。$var可以是任何变量名，像$length 或者 $name，和&lt;list or map&gt;是一个返回列表（list）或 map 的 SassScript 表达式。 @each 规则将$var设置为列表（list）或 map 中的每个项目，输出样式中包含使用$var的值。 例如： 12345@each $animal in puma, sea-slug, egret, salamander &#123; .#&#123;$animal&#125;-icon &#123; background-image: url(&apos;/images/#&#123;$animal&#125;.png&apos;); &#125;&#125; 编译为： 12345678.puma-icon &#123; background-image: url(&apos;/images/puma.png&apos;); &#125;.sea-slug-icon &#123; background-image: url(&apos;/images/sea-slug.png&apos;); &#125;.egret-icon &#123; background-image: url(&apos;/images/egret.png&apos;); &#125;.salamander-icon &#123; background-image: url(&apos;/images/salamander.png&apos;); &#125; 4.1.多重赋值（Multiple Assignment）@each指令也可以使用多个变量，格式为@each $var1,$var2, ... in &lt;list&gt;。如果&lt;list&gt;是列表（list）中的列表，子列表中的每个元素被分配给各自的变量。例如： 123456789@each $animal, $color, $cursor in (puma, black, default), (sea-slug, blue, pointer), (egret, white, move) &#123; .#&#123;$animal&#125;-icon &#123; background-image: url(&apos;/images/#&#123;$animal&#125;.png&apos;); border: 2px solid $color; cursor: $cursor; &#125;&#125; 编译为： 123456789101112.puma-icon &#123; background-image: url(&apos;/images/puma.png&apos;); border: 2px solid black; cursor: default; &#125;.sea-slug-icon &#123; background-image: url(&apos;/images/sea-slug.png&apos;); border: 2px solid blue; cursor: pointer; &#125;.egret-icon &#123; background-image: url(&apos;/images/egret.png&apos;); border: 2px solid white; cursor: move; &#125; 因为maps被视为键值对的列表，所以多重赋值也可以很好的工作。例如： 12345@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) &#123; #&#123;$header&#125; &#123; font-size: $size; &#125;&#125; 编译为： 123456h1 &#123; font-size: 2em; &#125;h2 &#123; font-size: 1.5em; &#125;h3 &#123; font-size: 1.2em; &#125; 5.@while@while 指令重复输出嵌套样式，直到SassScript表达式返回结果为false。这可用于实现比@for语句更复杂的循环，只是很少会用到例如： 12345$i: 6; @while $i &gt; 0 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125; $i: $i - 2;&#125; 编译为： 12345678.item-6 &#123; width: 12em; &#125;.item-4 &#123; width: 8em; &#125;.item-2 &#123; width: 4em; &#125;]]></content>
      <categories>
        <category>sass学习手记</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本溢出与 Tooltip，如何更好的处理二者]]></title>
    <url>%2F2019%2F06%2F03%2Fellpise%2F</url>
    <content type="text"><![CDATA[前言前端开发中文本溢出是一个非常常见的场景，如果在编程中没有对这部分进行处理，很可能会出现因为文本太长影响整体视觉效果或前端布局的情况。因此，对于有可能出现文本溢出的地方，我们需要对他们进行一些处理。当然，单纯地处理溢出很简单，如果要结合 Tooltip 做一些略复杂的交互显示，可能需要考虑更多的内容，接下来我们来对这些内容逐步的进行探讨： 实现文本溢出省略的处理方案目前而言，常见的处理方案可能分为以下几种情况，单行省略处理和多行省略，这部分的 CSS 方案在网上很容易能找得到。话不多少，先扔代码： 单行省略 12345div &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 核心的部分是 text-overflow: ellipsis; 但是有几个需要注意的点：这个属性只对那些在块级元素溢出的内容有效，而且必须要与块级元素内联(inline)方向一致，所以我们还需要加上 white-space: nowrap, 并将 overflow 设置为 hidden 以使得 text-overflow 生效。 多行省略 123456div &#123; display: -webkit-box; overflow: hidden; -webkit-line-clamp: 2; -webkit-box-orient: vertical;&#125; 这种方式实现的省略可以在文本超出规定行数时超出的部分按照 ...，当时它也只适用于 webkit 内核的浏览器。非 webkit 内核的实现方案需要用伪元素或 float 的方式来实现，这里我们不做讨论，感兴趣的朋友可以参考这篇博客。 Tooltip 结合 ellipsis关于 tooltip 的实现本文不做探讨，我们采用 Element 中的 Tooltip 作为示例进行演示： 阶段 1首先来进行暴力拼接，将文本的全部内容直接进行 Tooltip 显示而不用管是否会触发超出省略： 123&lt;el-tooltip :content=&quot;content&quot;&gt; &lt;div class=&quot;ellipsis-item&quot;&gt;&#123;&#123; content &#125;&#125;&lt;/div&gt;&lt;/el-tooltip&gt; 实现的内容大概是这个样子的： 但是这显然不是一个很好的解决方案，对于那些并没有溢出的文本，每次 hover 上去时还会显示 Tooltip，实在是一种糟心的体验。因此我们需要对上面的内容进行一些优化。 阶段 2这次我们要实现一个文本溢出时 hover 显示 Tooltip，不溢出时 hover 不显示的效果。但是我们在第一步文本溢出的配置中是用 css 来进行设置的，如何才能通过 JS 来控制什么显示 Tooltip 的时机呢？这就要从文本溢出的原理讲起了： 我们知道，每一个 HTML 元素都具有：clientHeight(clientWidth)、offsetHeight(offsetWidth)、scrollHeight(scrollWidth)、offsetTop(offsetLeft)、scrollTop(scrollLeft) 五种类型的属性，他们分别表示： clientHeight(clientWidth): 对象内容的可视区的高度（宽度）。包括 padding 但不包括 border、水平滚动条、margin 的元素的高度(宽度）。对于 inline 的元素这个属性一直是 0 offsetHeight(offsetWidth): 对象整体的实际高度（宽度）。包括 padding、border、水平滚动条，但不包括 margin 的元素的高度（宽度）。对于inline的元素这个属性一直是 0，单位 px。 scrollHeight(scrollWidth): 对象的实际内容的高度（宽度）。当实际内容超出可视区时会通过出现滚动条，通过滚动条可以调节实际内容在可视区的显示部分。 scrollTop(scrollLeft): 在有滚动条时，滚动条向下（向右）滚动的距离也就是元素顶部（左侧）被遮住部分的高度（宽度）。 offsetTop(offsetLeft): 当前元素顶部（左侧边框）距离最近的定位父元素顶部（左侧边框）的距离。 对于单行省略而言：当文本所在的块元素的实际宽度超过了可视区的宽度（即 scrollWidth 超过了 clientWidth)，那么就会被判定为文本超出，我们就可以看见熟悉的 ... 了。 同样的道理，对于多行省略而言：文本检测超长的方式并不是 inline 的方向，而是垂直方向，所以我们同理变换即可理解，也就是说，党文在所在快元素的实际高度超过了可视区的高度（即 scrollHeight 超过了 clientHeight），那么就会被判定为文本超出。 根据以上部分的原理，我们可以很容易的实现文本超长 hover 时显示 tooltip，而不超长时候不作处理的方法： 12345678&lt;el-tooltip v-if=&quot;showTooltip&quot; :content=&quot;content&quot;&gt; &lt;div ref=&quot;content&quot; class=&quot;ellipsis-item&quot;&gt;&#123;&#123; content &#125;&#125;&lt;/div&gt;&lt;/el-tooltip&gt;&lt;div v-else ref=&quot;content&quot; class=&quot;ellipsis-item&quot;&gt;&#123;&#123; content &#125;&#125;&lt;/div&gt;this.showTooltip = this.$refs.content.offsetWidth &lt; this.$refs.content.scrollWidth || // 处理单行省略 this.$refs.name.offsetHeight &lt; this.$refs.name.scrollHeight; // 处理多行省略 所以一些看似比较复杂的应用场景其实都是基本的原理拼接而成的，我们在了解这些原理之后便可以举一反三玩出很多的花样来。就这么简单~ 参考资料：http://imweb.io/topic/57c5409e808fd2fb204eef52https://www.w3.org/TR/cssom-view]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>ellpise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4类 JavaScript 内存泄漏及如何避免]]></title>
    <url>%2F2019%2F05%2F23%2Fmemory%2F</url>
    <content type="text"><![CDATA[原文：4 Types of Memory Leaks in JavaScript and How to Get Rid Of Them 译者注：本文并没有逐字逐句的翻译，而是把我认为重要的信息做了翻译。如果您的英文熟练，可以直接阅读原文。 本文将探索常见的客户端 JavaScript 内存泄漏，以及如何使用 Chrome 开发工具发现问题。 简介内存泄漏是每个开发者最终都要面对的问题，它是许多问题的根源：反应迟缓，崩溃，高延迟，以及其他应用问题。 什么是内存泄漏？本质上，内存泄漏可以定义为：应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收。编程语言管理内存的方式各不相同。只有开发者最清楚哪些内存不需要了，操作系统可以回收。一些编程语言提供了语言特性，可以帮助开发者做此类事情。另一些则寄希望于开发者对内存是否需要清晰明了。 JavaScript 内存管理JavaScript 是一种垃圾回收语言。垃圾回收语言通过周期性地检查先前分配的内存是否可达，帮助开发者管理内存。换言之，垃圾回收语言减轻了“内存仍可用”及“内存仍可达”的问题。两者的区别是微妙而重要的：仅有开发者了解哪些内存在将来仍会使用，而不可达内存通过算法确定和标记，适时被操作系统回收。 JavaScript 内存泄漏垃圾回收语言的内存泄漏主因是不需要的引用。理解它之前，还需了解垃圾回收语言如何辨别内存的可达与不可达。 Mark-and-sweep大部分垃圾回收语言用的算法称之为 Mark-and-sweep 。算法由以下几步组成： 垃圾回收器创建了一个“roots”列表。Roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）； 所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。 所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。 现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。 不需要的引用是指开发者明知内存引用不再需要，却由于某些原因，它仍被留在激活的 root 树中。在 JavaScript 中，不需要的引用是保留在代码中的变量，它不再需要，却指向一块本该被释放的内存。有些人认为这是开发者的错误。 为了理解 JavaScript 中最常见的内存泄漏，我们需要了解哪种方式的引用容易被遗忘。 三种类型的常见 JavaScript 内存泄漏1：意外的全局变量JavaScript 处理未定义变量的方式比较宽松：未定义的变量会在全局对象创建一个新变量。在浏览器中，全局对象是 window。 123function foo(arg) &#123; bar = &quot;this is a hidden global variable&quot;;&#125; 真相是： 123function foo(arg) &#123; window.bar = &quot;this is an explicit global variable&quot;;&#125; 函数 foo 内部忘记使用 var ，意外创建了一个全局变量。此例泄漏了一个简单的字符串，无伤大雅，但是有更糟的情况。 另一种意外的全局变量可能由 this 创建： 1234567function foo() &#123; this.variable = &quot;potential accidental global&quot;;&#125;// Foo 调用自己，this 指向了全局对象（window）// 而不是 undefinedfoo(); 在 JavaScript 文件头部加上 &#39;use strict&#39;，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量。 全局变量注意事项 尽管我们讨论了一些意外的全局变量，但是仍有一些明确的全局变量产生的垃圾。它们被定义为不可回收（除非定义为空或重新分配）。尤其当全局变量用于临时存储和处理大量信息时，需要多加小心。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用。高内存消耗导致缓存突破上限，因为缓存内容无法被回收。 2：被遗忘的计时器或回调函数在 JavaScript 中使用 setInterval 非常平常。一段常见的代码： 12345678var someResource = getData();setInterval(function() &#123; var node = document.getElementById(&apos;Node&apos;); if(node) &#123; // 处理 node 和 someResource node.innerHTML = JSON.stringify(someResource)); &#125;&#125;, 1000); 此例说明了什么：与节点或数据关联的计时器不再需要，node 对象可以删除，整个回调函数也不需要了。可是，计时器回调函数仍然没被回收（计时器停止才会被回收）。同时，someResource 如果存储了大量的数据，也是无法被回收的。 对于观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。如今，即使没有明确移除它们，一旦观察者对象变成不可达，大部分浏览器是可以回收观察者处理函数的。 观察者代码示例： 123456var element = document.getElementById(&apos;button&apos;);function onClick(event) &#123; element.innerHTML = &apos;text&apos;;&#125;element.addEventListener(&apos;click&apos;, onClick); 对象观察者和循环引用注意事项 老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。如今，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法，已经可以正确检测和处理循环引用了。换言之，回收节点内存时，不必非要调用 removeEventListener 了。 3：脱离 DOM 的引用有时，保存 DOM 节点内部数据结构很有用。假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用都清除。 1234567891011121314151617181920var elements = &#123; button: document.getElementById(&apos;button&apos;), image: document.getElementById(&apos;image&apos;), text: document.getElementById(&apos;text&apos;)&#125;;function doStuff() &#123; image.src = &apos;http://some.url/image&apos;; button.click(); console.log(text.innerHTML); // 更多逻辑&#125;function removeButton() &#123; // 按钮是 body 的后代元素 document.body.removeChild(document.getElementById(&apos;button&apos;)); // 此时，仍旧存在一个全局的 #button 的引用 // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。&#125; 此外还要考虑 DOM 树内部或子节点的引用问题。假如你的 JavaScript 代码中保存了表格某一个 &lt;td&gt; 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的 &lt;td&gt; 以外的其它节点。实际情况并非如此：此 &lt;td&gt; 是表格的子节点，子元素与父元素是引用关系。由于代码保留了 &lt;td&gt; 的引用，导致整个表格仍待在内存中。保存 DOM 元素引用的时候，要小心谨慎。 4：闭包闭包是 JavaScript 开发的一个关键方面：匿名函数可以访问父级作用域的变量。 代码示例： 1234567891011121314151617var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) console.log(&quot;hi&quot;); &#125;; theThing = &#123; longStr: new Array(1000000).join(&apos;*&apos;), someMethod: function () &#123; console.log(someMessage); &#125; &#125;;&#125;;setInterval(replaceThing, 1000); 代码片段做了一件事情：每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。思绪混乱了吗？最重要的事情是，闭包的作用域一旦创建，它们有同样的父级作用域，作用域是共享的。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。当这段代码反复运行，就会看到内存占用不断上升，垃圾回收器（GC）并无法降低内存占用。本质上，闭包的链表已经创建，每一个闭包作用域携带一个指向大数组的间接的引用，造成严重的内存泄漏。 Meteor 的博文 解释了如何修复此种问题。在 replaceThing 的最后添加 originalThing = null 。 Chrome 内存剖析工具概览Chrome 提供了一套很棒的检测 JavaScript 内存占用的工具。与内存相关的两个重要的工具：timeline 和 profiles。 Timeline timeline 可以检测代码中不需要的内存。在此截图中，我们可以看到潜在的泄漏对象稳定的增长，数据采集快结束时，内存占用明显高于采集初期，Node（节点）的总量也很高。种种迹象表明，代码中存在 DOM 节点泄漏的情况。 Profiles Profiles 是你可以花费大量时间关注的工具，它可以保存快照，对比 JavaScript 代码内存使用的不同快照，也可以记录时间分配。每一次结果包含不同类型的列表，与内存泄漏相关的有 summary（概要） 列表和 comparison（对照） 列表。 summary（概要） 列表展示了不同类型对象的分配及合计大小：shallow size（特定类型的所有对象的总大小），retained size（shallow size 加上其它与此关联的对象大小）。它还提供了一个概念，一个对象与关联的 GC root 的距离。 对比不同的快照的 comparison list 可以发现内存泄漏。 实例：使用 Chrome 发现内存泄漏实质上有两种类型的泄漏：周期性的内存增长导致的泄漏，以及偶现的内存泄漏。显而易见，周期性的内存泄漏很容易发现；偶现的泄漏比较棘手，一般容易被忽视，偶尔发生一次可能被认为是优化问题，周期性发生的则被认为是必须解决的 bug。 以 Chrome 文档中的代码为例： 123456789101112131415161718192021var x = [];function createSomeNodes() &#123; var div, i = 100, frag = document.createDocumentFragment(); for (;i &gt; 0; i--) &#123; div = document.createElement(&quot;div&quot;); div.appendChild(document.createTextNode(i + &quot; - &quot;+ new Date().toTimeString())); frag.appendChild(div); &#125; document.getElementById(&quot;nodes&quot;).appendChild(frag);&#125;function grow() &#123; x.push(new Array(1000000).join(&apos;x&apos;)); createSomeNodes(); setTimeout(grow,1000);&#125; 当 grow 执行的时候，开始创建 div 节点并插入到 DOM 中，并且给全局变量分配一个巨大的数组。通过以上提到的工具可以检测到内存稳定上升。 找出周期性增长的内存timeline 标签擅长做这些。在 Chrome 中打开例子，打开 Dev Tools ，切换到 timeline，勾选 memory 并点击记录按钮，然后点击页面上的 The Button 按钮。过一阵停止记录看结果： 两种迹象显示出现了内存泄漏，图中的 Nodes（绿线）和 JS heap（蓝线）。Nodes 稳定增长，并未下降，这是个显著的信号。 JS heap 的内存占用也是稳定增长。由于垃圾收集器的影响，并不那么容易发现。图中显示内存占用忽涨忽跌，实际上每一次下跌之后，JS heap 的大小都比原先大了。换言之，尽管垃圾收集器不断的收集内存，内存还是周期性的泄漏了。 确定存在内存泄漏之后，我们找找根源所在。 保存两个快照切换到 Chrome Dev Tools 的 profiles 标签，刷新页面，等页面刷新完成之后，点击 Take Heap Snapshot 保存快照作为基准。而后再次点击 The Button 按钮，等数秒以后，保存第二个快照。 筛选菜单选择 Summary，右侧选择 Objects allocated between Snapshot 1 and Snapshot 2，或者筛选菜单选择 Comparison ，然后可以看到一个对比列表。 此例很容易找到内存泄漏，看下 (string) 的 Size Delta Constructor，8MB，58个新对象。新对象被分配，但是没有释放，占用了8MB。 如果展开 (string) Constructor，会看到许多单独的内存分配。选择某一个单独的分配，下面的 retainers 会吸引我们的注意。 我们已选择的分配是数组的一部分，数组关联到 window 对象的 x 变量。这里展示了从巨大对象到无法回收的 root（window）的完整路径。我们已经找到了潜在的泄漏以及它的出处。 我们的例子还算简单，只泄漏了少量的 DOM 节点，利用以上提到的快照很容易发现。对于更大型的网站，Chrome 还提供了 Record Heap Allocations 功能。 Record heap allocations 找内存泄漏回到 Chrome Dev Tools 的 profiles 标签，点击 Record Heap Allocations。工具运行的时候，注意顶部的蓝条，代表了内存分配，每一秒有大量的内存分配。运行几秒以后停止。 上图中可以看到工具的杀手锏：选择某一条时间线，可以看到这个时间段的内存分配情况。尽可能选择接近峰值的时间线，下面的列表仅显示了三种 constructor：其一是泄漏最严重的（string），下一个是关联的 DOM 分配，最后一个是 Textconstructor（DOM 叶子节点包含的文本）。 从列表中选择一个 HTMLDivElement constructor，然后选择 Allocation stack。 现在知道元素被分配到哪里了吧（grow -&gt; createSomeNodes），仔细观察一下图中的时间线，发现 HTMLDivElementconstructor 调用了许多次，意味着内存一直被占用，无法被 GC 回收，我们知道了这些对象被分配的确切位置（createSomeNodes）。回到代码本身，探讨下如何修复内存泄漏吧。 另一个有用的特性在 heap allocations 的结果区域，选择 Allocation。 这个视图呈现了内存分配相关的功能列表，我们立刻看到了 grow 和 createSomeNodes。当选择 grow 时，看看相关的 object constructor，清楚地看到 (string), HTMLDivElement 和 Text 泄漏了。 结合以上提到的工具，可以轻松找到内存泄漏。 延伸阅读 Memory Management - Mozilla Developer Network JScript Memory Leaks - Douglas Crockford (old, in relation to Internet Explorer 6 leaks) JavaScript Memory Profiling - Chrome Developer Docs Memory Diagnosis - Google Developers An Interesting Kind of JavaScript Memory Leak - Meteor blog Grokking V8 closures]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>内存泄露</tag>
        <tag>chrome调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在create-react-app中搭配tslint]]></title>
    <url>%2F2019%2F04%2F24%2Fcreate-react-app-tslint%2F</url>
    <content type="text"><![CDATA[创建React和TypeScript项目现在创建React和TypeScript应用程序非常简单。在CRA 2.1 TypeScript之前，我们必须使用单独的脚本将TypeScript包含在我们的React应用程序中。从CRA 2.1开始，TypeScript支持就在框中。我们只需要安装npm 5.2或更高版本。 创建我们的项目让我们在我们选择的文件夹中运行以下命令，我们要在其中创建项目： 1npx create-react-app app --typescript 该npx工具临时安装create-react-appnpm包并使用它来创建我们的项目。整齐！ 我们选择调用我们的项目应用程序。 我们还指定--typescript了一个位，告诉工具使用TypeScript设置项目。 该工具将花费一分钟左右来创建我们的项目。 添加TSLint将TSLint添加到React和TypeScript有助于我们使代码更具可读性和可维护性。遗憾的是，CRA在其设置中不包含此内容，因此，我们将通过在终端中运行以下命令来自行完成此操作： 123cd appnpm install tslint tslint-react --save-dev 我们刚刚安装了TSLint作为开发依赖项以及React项目的一些标准linting规则。 让我们通过添加一个与以下内容tslint.json 相同级别调用的文件来配置TSLint package.json： 12345&#123; &quot;extends&quot;: [&quot;tslint:latest&quot;, &quot;tslint-react&quot;], &quot;linterOptions&quot;: &#123;&quot;exclude&quot;: [&quot;config/**/*.js&quot;, &quot;node_modules/**/*.ts&quot;, &quot;coverage/lcov-report/*.js&quot;]&#125;&#125; 如果我们希望随着TSLint的发展，linting规则更加稳定，我们可以使用tslint:recommended而不是tslint:latest。 我们可以通过添加字段来覆盖我们想要的特定规则rules。 添加TSLint Visual Studio代码扩展该打字稿TSLint插件 VS代码扩展似乎是最流行的扩展，这些天。 安装此插件后，我们需要启用它tsconfig.json： 12345678&#123; &quot;compilerOptions&quot;: &#123; ..., &quot;plugins&quot;: [&#123;&quot;name&quot;: &quot;typescript-tslint-plugin&quot;&#125;] &#125;, ...&#125; 修复App.tsx中的linting错误现在我们的应用程序正在使用TSLint，我们在App需要修复的组件中遇到了一个小问题。 我们需要在render方法中添加访问修饰符： 123456class App extends Component &#123; public render() &#123; return ( ... ); &#125;&#125; 添加自动格式一些与我们的代码格式有关的linting规则（例如语句末尾的半冒号）可以通过像Prettier这样的工具自动处理。 我们可以通过在终端中执行以下命令来安装Prettier： 1npm install prettier --save-dev 为了让Prettier更好地使用TSLint，我们首先安装 tslint-config-prettier规则预设： 1npm install tslint-config-prettier --save-dev 然后我们将其添加到tslint.json： 1&#123; &quot;extends&quot;: [&quot;tslint:latest&quot;, &quot;tslint-react&quot;, &quot;tslint-config-prettier&quot;], &quot;linterOptions&quot;: &#123;&quot;exclude&quot;: [&quot;config//*.js&quot;, &quot;node_modules//.ts&quot;, &quot;coverage/lcov-report/.js&quot;]&#125;&#125; 我们在.prettierrc文件中指定我们想要的格式规则，该文件位于以下相同的级别package.json： 1&#123; &quot;printWidth&quot;: 80, &quot;singleQuote&quot;: true, &quot;semi&quot;: true, &quot;tabWidth&quot;: 2, &quot;trailingComma&quot;: &quot;all&quot;&#125; 添加更漂亮的Visual Studio代码扩展该更漂亮-代码格式化 VS代码扩展名是流行的扩展，这些天。 通过勾选“ 用户设置”中的“ 保存时格式”选项，我们可以让Prettier在Visual Studio代码中保存文件时应用格式： 运行应用程序像往常一样，我们可以通过在终端中输入以下命令来运行应用程序： npm start 就是这样 - 我们现在有一个带有TSLint和Prettier的React和TypeScript项目！ 参考文档 Creating a React and TypeScript Project 搭建Typescript+React项目模板(5) — 团队规范]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>create-react-app</tag>
        <tag>tslint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongod]]></title>
    <url>%2F2019%2F04%2F22%2Fmongodb%2F</url>
    <content type="text"><![CDATA[mongodb密码和传统数据如mysql等有些区别： mongodb的用户名和密码是基于特定数据库的，而不是基于整个系统的。所有所有数据库db都需要设置密码 mongodb设置管理用户和密码： show dbs在mongodb新版本里并没有admin数据库，但是并不妨碍第2步操作。 use admin 进入admin数据库 创建管理员账户db.createUser({ user: &quot;useradmin&quot;, pwd: &quot;adminpassword&quot;, roles: [{ role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; }] })mongodb中的用户是基于身份role的，该管理员账户的 role是 userAdminAnyDatabase。 ‘userAdmin’代表用户管理身份，’AnyDatabase’ 代表可以管理任何数据库。 验证第3步用户添加是否成功db.auth(&quot;useradmin&quot;, &quot;adminpassword&quot;) 如果返回1，则表示成功。exit退出系统db.auth()方法理解为 用户的验证功能 修改配置 1sudo vi /etc/mongod.conf ​ 找到 1#security: 取消注释，修改为： security: authorization: enabled #注意缩进，缩进参照配置文件其他配置。缩进错误可能第6步重启不成功。 重启mongodb sudo service mongod restart 进入mongodb,用第3步的 管理员账户登录，用该账户创建其他数据库管理员账号 use admin db.auth(&quot;useradmin&quot;, &quot;adminpassword&quot;) 新建你需要管理的mongodb 数据的账号密码。 #必须要use否则创建的不生效,连接也不生效，否则连接的时候只能用admin的数据库去连rotbo3T，但也可以看到自己的Database,也可以操作数据库 use yourdatabase db.createUser({ user: &quot;youruser&quot;, pwd: &quot;yourpassword&quot;, roles: [{ role: &quot;dbOwner&quot;, db: &quot;yourdatabase&quot; }] }) rote:dbOwner 代表数据库所有者角色，拥有最高该数据库最高权限。比如新建索引等 新建数据库读写账户 use yourdatabase db.createUser({ user: &quot;youruser2&quot;, pwd: &quot;yourpassword2&quot;, roles: [{ role: &quot;readWrite&quot;, db: &quot;yourdatabase&quot; }] }) 该用户用于该数据的读写，只拥有读写权限。 现在数据的用户名和密码就建好了。可以使用：mongodb://youruser2:yourpassword2@localhost/yourdatabase来链接 验证ps aux|grep mongo 12345mongod 3609 0.2 8.6 1087064 87484 ? Sl 13:32 0:30 /usr/bin/mongod -f /etc/mongod.confroot 4150 0.0 0.0 112724 988 pts/0 R+ 17:10 0:00 grep --color=auto mongo没起服务之前root 3574 0.0 0.0 112724 988 pts/0 R+ 13:28 0:00 grep --color=auto mongo 验证安全认证： use adminwitched to db adminshow dbs –没有认证查看数据库报错014-09-14T13:28:45.953+0800 listDatabases failed:{ “ok” : 0, “errmsg” : “not authorized on admin to execute command { listDatabases:.0 }”, “code” : 13 at src/mongo/shell/mongo.js:47 db.auth(“super”,”super”) —认证后再次查看ok1show dbsdmin 0.078GBocal 0.078GBest 0.078GBangwei 0.078GB 普通用户认证 show dbs –没有认证查看数据014-09-14T13:31:19.265+0800 listDatabases failed:{ “ok” : 0, “errmsg” : “not authorized on admin to execute command { listDatabases:.0 }”, “code” : 13 at src/mongo/shell/mongo.js:47 db.auth(“test”,”test”)1show dbs –认证后查看数据库还报错，原因这个用户属于test不属于admin014-09-14T13:33:30.062+0800 listDatabases failed:{ “ok” : 0, “errmsg” : “not authorized on admin to execute command { listDatabases:.0 }”, “code” : 13 at src/mongo/shell/mongo.js:47 E:\mongodb\bin&gt;mongo 127.0.0.1:27019MongoDB shell version: 2.6.4connecting to: 127.0.0.1:27019/test db.mycol.insert({“id”:222}) –没有认证情况插入文档失败WriteResult({ “writeError” : { “code” : 13, “errmsg” : “not authorized on test to execute command { insert:“mycol\”, documents: [ { _id: ObjectId(‘5415292f131751676caa7881’), id: 222.0 }], ordered: true }” }})db.auth(“test”,”test”) –认证后插入文档成功1db.mycol.insert({“id”:222})riteResult({ “nInserted” : 1 }) 只读用户认证E:\mongodb\bin&gt;mongo 127.0.0.1:27019MongoDB shell version: 2.6.4connecting to: 127.0.0.1:27019/test db.mycol.find() –没有认证查询失败rror: { “$err” : “not authorized for query on test.mycol”, “code” : 13 }db.auth(“readonly”.”readonly”)014-09-14T13:38:16.265+0800 SyntaxError: Unexpected stringdb.auth(“readonly”,”readonly”)1db.mycol.find() –认证后查询成功 “_id” : ObjectId(“5415294b131751676caa7882”), “id” : 222 } db.mycol.insert({“id”:5555}) –只读认证后，插入文档失败，原因用户是只读的WriteResult({ “writeError” : { “code” : 13, “errmsg” : “not authorized on test to execute command { insert:“mycol\”, documents: [ { _id: ObjectId(‘541529ead090e8f5c50762b9’), id: 5555.0 ], ordered: true }” }}) 参考文档 mongodb设置密码 MongoDB 基础（六）安全性（权限操作） mongodb的用户认证]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb-config</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb]]></title>
    <url>%2F2019%2F04%2F12%2Fmongodb%2F</url>
    <content type="text"><![CDATA[db.collection.aggregate()除了$out和$geoNear阶段之外的所有内容都可以在管道中多次出现 计算集合或视图中数据的聚合值 1db.collection.aggregate(pipeline, options) 参数 类型 描述 pipeline 排列 一系列数据聚合操作或阶段。有关详细信息，请参阅 聚合管道运算在2.6版中更改：该方法仍然可以将管道阶段作为单独的参数接受，而不是作为数组中的元素; 但是，如果未指定pipeline为数组，则无法指定 options参数。 options 文献 可选的。aggregate()传递给aggregate命令的其他选项。版本2.6中的新功能：仅在您指定pipeline为数组时可用。 该options文档可以包含以下字段和值： 领域 类型 描述 explain 布尔 可选的。指定返回有关管道处理的信息。有关示例，请参阅 聚合管道操作的返回信息。在多文档交易中不可用。 allowDiskUse 布尔 可选的。允许写入临时文件。设置为时true，聚合操作可以将数据写入_tmp目录中的 dbPath子目录。有关示例，请参阅 使用外部排序执行大型排序操作。2.6版中的新功能。 cursor 文献 可选的。指定游标的初始批处理大小。该cursor 字段的值是具有该字段的文档batchSize。有关语法和示例，请参阅 指定初始批处理大小。2.6版中的新功能。 maxTimeMS 非负整数 可选的。指定处理游标操作的时间限制（以毫秒为单位）。如果未指定maxTimeMS的值，则操作不会超时。值0显式指定默认的无界行为。MongoDB使用与其相同的机制终止超出其分配时间限制的操作db.killOp()。MongoDB仅终止其指定中断点之一的操作。 bypassDocumentValidation 布尔 可选的。仅在指定$out聚合运算符时可用。允许db.collection.aggregate在操作期间绕过文档验证。这使您可以插入不符合验证要求的文档。版本3.2中的新功能。 readConcern 文献 可选的。指定读取问题。readConcern选项具有以下语法：版本3.6中已更改。复制复制readConcern ： { level ： &lt; value &gt; }可能的阅读关注水平是：&quot;local&quot;。这是默认的读取关注级别。&quot;available&quot;。当读取操作和afterClusterTime以及“level”未指定时，这是对辅助节点的读取的默认值。查询返回实例的最新数据。&quot;majority&quot;。适用于使用WiredTiger存储引擎的副本集 。&quot;linearizable&quot;。仅适用于读取操作 primary。有关读取关注级别的更多信息，请参阅 读取关注级别。对于&quot;local&quot;（默认）或&quot;majority&quot;读取关注级别，您可以指定使afterClusterTime读取操作返回满足级别要求的数据和指定的群集时间要求的选项。有关更多信息，请参阅 读取操作和afterClusterTime。 collation 文献 可选的。指定 要用于操作的排序规则。排序规则允许用户为字符串比较指定特定于语言的规则，例如字母和重音标记的规则。排序规则选项具有以下语法：复制复制collation ： { locale ： &lt; string &gt; ， caseLevel ： &lt; boolean &gt; ， caseFirst ： &lt; string &gt; ， strength ： &lt; int &gt; ， numericOrdering ： &lt; boolean &gt; ， alternate ： &lt; string &gt; ， maxVariable ： &lt; string &gt; ， backwards ： &lt; boolean &gt; }指定排序规则时，该locale字段是必填字段; 所有其他校对字段都是可选的。有关字段的说明，请参阅排序文档。如果未指定排序规则但集合具有默认排序规则（请参阅参考资料db.createCollection()），则该操作将使用为集合指定的排序规则。如果没有为集合或操作指定排序规则，MongoDB使用先前版本中使用的简单二进制比较进行字符串比较。您无法为操作指定多个排序规则。例如，您不能为每个字段指定不同的排序规则，或者如果使用排序执行查找，则不能对查找使用一个排序规则，而对排序使用另一个排序规则。版本3.4中的新功能。 hint 字符串或文件 可选的。用于聚合的索引。索引位于运行聚合的初始集合/视图上。通过索引名称或索引规范文档指定索引。注意该hint不适$lookup和 $graphLookup阶段。版本3.6中的新功能。 comment 串 可选的。用户可以指定任意字符串，以帮助通过数据库探查器，currentOp和日志跟踪操作。版本3.6中的新功能。 一个光标通过聚集流水线操作的最后阶段产生的文件，或者如果包括 explain选项，提供了聚集操作的处理细节的文件。 阶段 描述 $addFields 向文档添加新字段。类似于 $project，$addFields重塑流中的每个文档; 具体而言，通过向输出文档添加新字段，该文档包含输入文档和新添加字段中的现有字段。 $bucket 根据指定的表达式和存储区边界，将传入的文档分组，称为存储桶。 $bucketAuto 根据指定的表达式将传入的文档分类为特定数量的组（称为存储桶）。自动确定存储桶边界，以尝试将文档均匀地分配到指定数量的存储桶中。 $collStats 返回有关集合或视图的统计信息。 $count 返回聚合管道此阶段的文档数量计数。 $facet 在同一组输入文档的单个阶段内处理多个聚合管道。支持创建能够在单个阶段中跨多个维度或方面表征数据的多面聚合。 $geoNear 基于与地理空间点的接近度返回有序的文档流。集成的功能 $match，$sort以及$limit地理空间数据。输出文档包括附加距离字段，并且可以包括位置标识符字段。 $graphLookup 对集合执行递归搜索。对于每个输出文档，添加一个新的数组字段，其中包含该文档的递归搜索的遍历结果。 $group 按指定的标识符表达式对文档进行分组，并将累加器表达式（如果已指定）应用于每个组。消耗所有输入文档，并为每个不同的组输出一个文档。输出文档仅包含标识符字段，如果指定，则包含累积字段。 $indexStats 返回有关集合的每个索引的使用的统计信息。 $limit 将未修改的前n个文档传递给管道，其中n是指定的限制。对于每个输入文档，输出一个文档（对于前n个文档）或零文档（在前n个文档之后）。 $listSessions 列出活动时间足以传播到system.sessions集合的所有会话。 $lookup 对同一数据库中的另一个集合执行左外连接，以 从“已连接”集合中过滤文档以进行处理。 $match 过滤文档流以仅允许匹配的文档未经修改地传递到下一个管道阶段。 $match使用标准的MongoDB查询。对于每个输入文档，输出一个文档（匹配）或零文档（不匹配）。 $out 将聚合管道的结果文档写入集合。要使用$out舞台，它必须是管道中的最后一个阶段。 $project 重新整形流中的每个文档，例如添加新字段或删除现有字段。对于每个输入文档，输出一个文档。 $redact 通过基于文档本身中存储的信息限制每个文档的内容来重塑流中的每个文档。包含$project和的功能 $match。可用于实现字段级别的编辑。对于每个输入文档，输出一个或零个文档。 $replaceRoot 用指定的嵌入文档替换文档。该操作将替换输入文档中的所有现有字段，包括_id字段。指定嵌入在输入文档中的文档以将嵌入文档提升到顶层。 $sample 从输入中随机选择指定数量的文档。 $skip 跳过前n个文档，其中n是指定的跳过编号，并将未修改的其余文档传递给管道。对于每个输入文档，输出零文档（对于前n个文档）或一个文档（如果在前n个文档之后）。 $sort 按指定的排序键重新排序文档流。只有订单改变; 文件保持不变。对于每个输入文档，输出一个文档。 $sortByCount 根据指定表达式的值对传入文档进行分组，然后计算每个不同组中的文档计数。 $unwind 从输入文档解构数组字段以输出每个元素的文档。每个输出文档都使用元素值替换数组。对于每个输入文档，输出n个文档，其中n是数组元素的数量，对于空数组，可以为零。 对于要在管道阶段中使用的聚合表达式运算符，请参阅 聚合管道运算符。 1expression：聚合表达式 db.aggregate()从3.6版开始，MongoDB还提供了以下 db.aggregate方法：以下阶段使用db.aggregate()方法而不是db.collection.aggregate()方法。 阶段 描述 $currentOp 返回有关MongoDB部署的活动和/或休眠操作的信息。 $listLocalSessions 列出最近在当前连接mongos或mongod 实例上使用的所有活动会话。这些会话可能尚未传播到system.sessions集合中。 聚合api$project（更改原有字段的输出，维度是_id，即每一条数据不变） 将包含请求字段的文档传递到管道中的下一个阶段。指定的字段可以是输入文档或新计算字段中的现有字段。 1&#123; $project: &#123; &lt;specification(s)&gt; &#125; &#125; 该$project需要，可以指定包含字段的压制文档_id领域，增加新的字段，以及现有字段的值的复位。或者，您可以指定 字段的排除。 该$project规范有以下几种形式： 形成 描述 &lt;field&gt;: &lt;1 or true&gt; 指定包含字段。 _id: &lt;0 or false&gt; 指定_id字段的抑制。要有条件地排除字段，请改用REMOVE 变量。有关详细信息，请参阅有条件地排除字段。 &lt;field&gt;: &lt;expression&gt; 添加新字段或重置现有字段的值。在版本3.6中更改： MongoDB 3.6添加了变量REMOVE。如果表达式求值为$$REMOVE，则在输出中排除该字段。有关详细信息，请参阅有条件地排除字段。 &lt;field&gt;:&lt;0 or false&gt; 版本3.4中的新功能。指定排除字段。要有条件地排除字段，请改用REMOVE 变量。有关详细信息，请参阅有条件地排除字段。如果您指定排除其他字段_id，则不能使用任何其他$project 规范表单。此限制不适用于使用REMOVE 变量有条件地排除字段。 注意事项包含现有字段 _id默认情况下，该字段包含在输出文档中。要在输出文档中包含输入文档中的任何其他字段，必须明确指定包含在中 $project。 如果指定包含文档中不存在的字段，则$project忽略该字段包含，并且不将该字段添加到文档中。 取消_id字段默认情况下，该_id字段包含在输出文档中。要从_id输出文档中排除字段，必须明确指定_id字段 的抑制$project。 排除字段版本3.4中的新功能。 如果指定排除某个或多个字段，则在输出文档中返回所有其他字段。 如果指定排除除以外的字段_id，则不能使用任何其他$project规范表单：即，如果排除字段，则不能指定包含字段，重置现有字段的值或添加新字段。此限制不适用于使用REMOVE变量对字段进行条件排除 。 有条件地排除字段版本3.6中的新功能。 从MongoDB 3.6开始，您可以使用REMOVE聚合表达式中的变量来有条件地抑制字段。有关示例，请参阅有条件排除字段。 添加新字段或重置现有字段要添加新字段或重置现有字段的值，请指定字段名称并将其值设置为某个表达式。有关表达式的更多信息，请参阅表达式。 文字值若要将字段值直接设置为数字或布尔文字，而不是将字段设置为解析为文字的表达式，请使用$literal运算符。否则， $project将数字或布尔文字视为包含或排除字段的标志。 字段重命名通过指定新字段并将其值设置为现有字段的字段路径，可以有效地重命名字段。 新数组字段从MongoDB 3.2开始，$projectstage支持使用方括号[]直接创建新的数组字段。如果数组规范包含文档中不存在的字段，则该操作将替换null为该字段的值。有关示例，请参阅Project New Array Fields。 嵌入文档字段在嵌入文档中投影或添加/重置字段时，您可以使用点表示法，如 &quot;contact.address.country&quot;: &lt;1 or 0 or expression&gt; contact: { address: { country: &lt;1 or 0 or expression&gt; } } 当嵌套的领域，你不能使用点表示法嵌入文档中指定的领域，比如是无效的。contact: {&quot;address.country&quot;: &lt;1 or 0 or expression&gt; } 限制在版本3.4中更改。 如果$project 规范是空文档，MongoDB 3.4及更高版本会产生错误。 示例1.在输出文档中包含特定字段考虑一个books包含以下文档的集合： 1234567891011121314&#123; &quot;_id&quot; : 1, title: &quot;abc123&quot;, isbn: &quot;0001122223334&quot;, author: &#123; last: &quot;zzz&quot;, first: &quot;aaa&quot; &#125;, copies: 5&#125;$project阶段只包括_id， title和author在其输出文档的字段：db.books.aggregate( [ &#123; $project : &#123; title : 1 , author : 1 &#125; &#125; ] )结果&#123; &quot;_id&quot; : 1, &quot;title&quot; : &quot;abc123&quot;, &quot;author&quot; : &#123; &quot;last&quot; : &quot;zzz&quot;, &quot;first&quot; : &quot;aaa&quot; &#125; &#125; 2.抑制_id输出文档中的字段_id默认情况下始终包含该字段。要从舞台_id 的输出文档中$project排除该_id字段，请通过0在投影文档中将其设置为指定字段的排除。 考虑一个books包含以下文档的集合： 12345678910111213&#123; &quot;_id&quot; : 1, title: &quot;abc123&quot;, isbn: &quot;0001122223334&quot;, author: &#123; last: &quot;zzz&quot;, first: &quot;aaa&quot; &#125;, copies: 5&#125;以下$project阶段排除了该_id字段，但包括其输出文档中title的author字段和字段：db.books.aggregate( [ &#123; $project : &#123; _id: 0, title : 1 , author : 1 &#125; &#125; ] )结果&#123; &quot;title&quot; : &quot;abc123&quot;, &quot;author&quot; : &#123; &quot;last&quot; : &quot;zzz&quot;, &quot;first&quot; : &quot;aaa&quot; &#125; &#125; 3.从输出文档中排除字段版本3.4中的新功能。 考虑一个books包含以下文档的集合 1234567891011&#123; &quot;_id&quot; : 1, title: &quot;abc123&quot;, isbn: &quot;0001122223334&quot;, author: &#123; last: &quot;zzz&quot;, first: &quot;aaa&quot; &#125;, copies: 5, lastModified: &quot;2016-07-28&quot;&#125;以下$project阶段lastModified 从输出中排除字段db.books.aggregate( [ &#123; $project : &#123; &quot;lastModified&quot;: 0 &#125; &#125; ] ) 从嵌入式文档中排除字段版本3.4中的新功能。 考虑一个books包含以下文档的集合 12345678910111213141516171819202122232425&#123; &quot;_id&quot; : 1, title: &quot;abc123&quot;, isbn: &quot;0001122223334&quot;, author: &#123; last: &quot;zzz&quot;, first: &quot;aaa&quot; &#125;, copies: 5, lastModified: &quot;2016-07-28&quot;&#125;以下$project阶段从输出中排除author.first 和lastModified字段：db.books.aggregate( [ &#123; $project : &#123; &quot;author.first&quot; : 0, &quot;lastModified&quot; : 0 &#125; &#125; ] )或者，您可以将排除规范嵌套在文档中：db.bookmarks.aggregate( [ &#123; $project: &#123; &quot;author&quot;: &#123; &quot;first&quot;: 0&#125;, &quot;lastModified&quot; : 0 &#125; &#125; ] )两种规格都会产生相同的输出：&#123; &quot;_id&quot; : 1, &quot;title&quot; : &quot;abc123&quot;, &quot;isbn&quot; : &quot;0001122223334&quot;, &quot;author&quot; : &#123; &quot;last&quot; : &quot;zzz&quot; &#125;, &quot;copies&quot; : 5,&#125; 4.有条件地排除字段版本3.6中的新功能。 从MongoDB 3.6开始，您可以使用REMOVE聚合表达式中的变量来有条件地抑制字段。 考虑一个books包含以下文档的集合： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#123; &quot;_id&quot; : 1, title: &quot;abc123&quot;, isbn: &quot;0001122223334&quot;, author: &#123; last: &quot;zzz&quot;, first: &quot;aaa&quot; &#125;, copies: 5, lastModified: &quot;2016-07-28&quot;&#125;&#123; &quot;_id&quot; : 2, title: &quot;Baked Goods&quot;, isbn: &quot;9999999999999&quot;, author: &#123; last: &quot;xyz&quot;, first: &quot;abc&quot;, middle: &quot;&quot; &#125;, copies: 2, lastModified: &quot;2017-07-21&quot;&#125;&#123; &quot;_id&quot; : 3, title: &quot;Ice Cream Cakes&quot;, isbn: &quot;8888888888888&quot;, author: &#123; last: &quot;xyz&quot;, first: &quot;abc&quot;, middle: &quot;mmm&quot; &#125;, copies: 5, lastModified: &quot;2017-07-22&quot;&#125;以下$project阶段仅在等于以下情况时才使用该REMOVE 变量排除该author.middle字段&quot;&quot;：db.books.aggregate( [ &#123; $project: &#123; title: 1, &quot;author.first&quot;: 1, &quot;author.last&quot; : 1, &quot;author.middle&quot;: &#123; $cond: &#123; if: &#123; $eq: [ &quot;&quot;, &quot;$author.middle&quot; ] &#125;, then: &quot;$$REMOVE&quot;, else: &quot;$author.middle&quot; &#125; &#125; &#125; &#125;] )聚合操作会产生以下输出：&#123; &quot;_id&quot; : 1, &quot;title&quot; : &quot;abc123&quot;, &quot;author&quot; : &#123; &quot;last&quot; : &quot;zzz&quot;, &quot;first&quot; : &quot;aaa&quot; &#125; &#125;&#123; &quot;_id&quot; : 2, &quot;title&quot; : &quot;Baked Goods&quot;, &quot;author&quot; : &#123; &quot;last&quot; : &quot;xyz&quot;, &quot;first&quot; : &quot;abc&quot; &#125; &#125;&#123; &quot;_id&quot; : 3, &quot;title&quot; : &quot;Ice Cream Cakes&quot;, &quot;author&quot; : &#123; &quot;last&quot; : &quot;xyz&quot;, &quot;first&quot; : &quot;abc&quot;, &quot;middle&quot; : &quot;mmm&quot; &#125; &#125; 5.包含嵌入式文档中的特定字段考虑一个bookmarks包含以下文档的集合： 123456789101112&#123; _id: 1, user: &quot;1234&quot;, stop: &#123; title: &quot;book1&quot;, author: &quot;xyz&quot;, page: 32 &#125; &#125;&#123; _id: 2, user: &quot;7890&quot;, stop: [ &#123; title: &quot;book2&quot;, author: &quot;abc&quot;, page: 5 &#125;, &#123; title: &quot;book3&quot;, author: &quot;ijk&quot;, page: 100 &#125; ] &#125;要仅在title字段中包含嵌入文档中的 stop字段，可以使用点表示法db.bookmarks.aggregate( [ &#123; $project: &#123; &quot;stop.title&quot;: 1 &#125; &#125; ] )或者，您可以将包含规范嵌套在文档中：db.bookmarks.aggregate( [ &#123; $project: &#123; stop: &#123; title: 1 &#125; &#125; &#125; ] )这两个规范都会产生以下文件：&#123; &quot;_id&quot; : 1, &quot;stop&quot; : &#123; &quot;title&quot; : &quot;book1&quot; &#125; &#125;&#123; &quot;_id&quot; : 2, &quot;stop&quot; : [ &#123; &quot;title&quot; : &quot;book2&quot; &#125;, &#123; &quot;title&quot; : &quot;book3&quot; &#125; ] &#125; 6.包含计算字段考虑一个books包含以下文档的集合： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; &quot;_id&quot; : 1, title: &quot;abc123&quot;, isbn: &quot;0001122223334&quot;, author: &#123; last: &quot;zzz&quot;, first: &quot;aaa&quot; &#125;, copies: 5&#125;下$project阶段增加了新的领域 isbn，lastName以及copiesSold：db.books.aggregate( [ &#123; $project: &#123; title: 1, isbn: &#123; prefix: &#123; $substr: [ &quot;$isbn&quot;, 0, 3 ] &#125;, group: &#123; $substr: [ &quot;$isbn&quot;, 3, 2 ] &#125;, publisher: &#123; $substr: [ &quot;$isbn&quot;, 5, 4 ] &#125;, title: &#123; $substr: [ &quot;$isbn&quot;, 9, 3 ] &#125;, checkDigit: &#123; $substr: [ &quot;$isbn&quot;, 12, 1] &#125; &#125;, lastName: &quot;$author.last&quot;, copiesSold: &quot;$copies&quot; &#125; &#125; ])操作结果如下：&#123; &quot;_id&quot; : 1, &quot;title&quot; : &quot;abc123&quot;, &quot;isbn&quot; : &#123; &quot;prefix&quot; : &quot;000&quot;, &quot;group&quot; : &quot;11&quot;, &quot;publisher&quot; : &quot;2222&quot;, &quot;title&quot; : &quot;333&quot;, &quot;checkDigit&quot; : &quot;4&quot; &#125;, &quot;lastName&quot; : &quot;zzz&quot;, &quot;copiesSold&quot; : 5&#125; 7.项目新数组字段例如，如果集合包含以下文档： 12345678&#123; &quot;_id&quot; : ObjectId(&quot;55ad167f320c6be244eb3b95&quot;), &quot;x&quot; : 1, &quot;y&quot; : 1 &#125;以下操作将字段x和y元素作为新字段的项目myArray：db.collection.aggregate( [ &#123; $project: &#123; myArray: [ &quot;$x&quot;, &quot;$y&quot; ] &#125; &#125; ] )&#123; &quot;_id&quot; : ObjectId(&quot;55ad167f320c6be244eb3b95&quot;), &quot;myArray&quot; : [ 1, 1 ] &#125; 如果数组规范包含文档中不存在的字段，则该操作将替换null为该字段的值。 例如，给定相同的文档如上述，以下的动作项目的字段x，y以及一个不存在的字段 $someField作为一个新的领域元素myArray： 1234db.collection.aggregate( [ &#123; $project: &#123; myArray: [ &quot;$x&quot;, &quot;$y&quot;, &quot;$someField&quot; ] &#125; &#125; ] )&#123; &quot;_id&quot; : ObjectId(&quot;55ad167f320c6be244eb3b95&quot;), &quot;myArray&quot; : [ 1, 1, null ] &#125; $out 获取聚合管道返回的文档并将它们写入指定的集合。该$out操作者必须在最后阶段的管道。 版本3.2.0中已更改： MongoDB 3.2添加了对文档验证的支持。该bypassDocumentValidation 字段使您可以$out在聚合操作阶段绕过文档验证 。这使您可以插入不符合验证要求的文档。指定bypassDocumentValidation聚合方法或命令的选项。 { $out: &quot;&lt;output-collection&gt;&quot; } $out 获取一个指定输出集合名称的字符串。 重要 您不能将分片集合指定为输出集合。管道的输入集合可以分片。 该$out运营商不能将结果写入 封顶集合。 行为创建新集合$out如果当前数据库尚不存在，则该操作将在当前数据库中创建新集合。在聚合完成之前，集合不可见。如果聚合失败，MongoDB不会创建集合。 替换现有集合如果$out操作指定的集合已存在，则在完成聚合后，该$out 阶段将使用新结果集合原子替换现有集合。具体来说，$out操作： 创建临时集合。 将索引从现有集合复制到临时集合。 将文档插入临时集合中。 调用db.collection.renameCollection与 到临时集合重命名为目的地集合。dropTarget: true 该$out操作不会更改先前集合中存在的任何索引。如果聚合失败，则$out操作不会对预先存在的集合进行任何更改。 索引约束如果管道生成的文档违反任何唯一索引（包括_id原始输出集合字段的索引），则管道将无法完成 。 交易$out在交易中不允许。 示例集合books包含以下文档： 12345678910111213141516&#123; &quot;_id&quot; : 8751, &quot;title&quot; : &quot;The Banquet&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 2 &#125;&#123; &quot;_id&quot; : 8752, &quot;title&quot; : &quot;Divine Comedy&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 1 &#125;&#123; &quot;_id&quot; : 8645, &quot;title&quot; : &quot;Eclogues&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 2 &#125;&#123; &quot;_id&quot; : 7000, &quot;title&quot; : &quot;The Odyssey&quot;, &quot;author&quot; : &quot;Homer&quot;, &quot;copies&quot; : 10 &#125;&#123; &quot;_id&quot; : 7020, &quot;title&quot; : &quot;Iliad&quot;, &quot;author&quot; : &quot;Homer&quot;, &quot;copies&quot; : 10 &#125;以下聚合操作将books 集合中的数据转向以按作者分组标题，然后将结果写入authors集合。db.books.aggregate( [ &#123; $group : &#123; _id : &quot;$author&quot;, books: &#123; $push: &quot;$title&quot; &#125; &#125; &#125;, &#123; $out : &quot;authors&quot; &#125; ] ) &#123; &quot;_id&quot; : &quot;Homer&quot;, &quot;books&quot; : [ &quot;The Odyssey&quot;, &quot;Iliad&quot; ] &#125;&#123; &quot;_id&quot; : &quot;Dante&quot;, &quot;books&quot; : [ &quot;The Banquet&quot;, &quot;Divine Comedy&quot;, &quot;Eclogues&quot; ] &#125; $group（根据不同的字段进行统计，或者输出） 按一些指定的表达式对文档进行分组，并为每个不同的分组输出到下一个阶段的文档。输出文档包含一个_id按键包含不同组的字段。输出文档还可以包含存储由分组一些累加器表达式的值来计算字段 $group的_id字段。$group并没有 责令其输出文档。 该$group阶段具有以下原型形式： 1&#123; $ group ： &#123;_ id ： &lt; expression &gt; ， &lt; field1 &gt;： &#123; &lt; accumulator1 &gt; ： &lt; expression1 &gt; &#125;， ... &#125; &#125; 该_id字段是强制性的 ; 但是，您可以指定 _idnull值或任何其他常量值，以计算所有输入文档的累计值。 其余的计算字段是可选的，并使用&lt;accumulator&gt;运算符计算 。 在_id和&lt;accumulator&gt;表达式可以接受任何有效的表达。有关表达式的更多信息，请参阅表达式 注意事项累加运算符该&lt;accumulator&gt;操作必须是以下之一： 名称 描述 $addToSet 返回每个组的唯一表达式值数组。数组元素的顺序未定义。 $avg 返回数值的平均值。忽略非数字值。 $first 返回每个组的第一个文档中的值。仅在文档按定义的顺序定义时才定义订单。 $last 返回每个组的最后一个文档的值。仅在文档按定义的顺序定义时才定义订单。 $max 返回每个组的最高表达式值。 $mergeObjects 返回通过组合每个组的输入文档创建的文档。 $min 返回每个组的最低表达式值。 $push 返回每个组的表达式值数组。 $stdDevPop 返回输入值的总体标准偏差。 $stdDevSamp 返回输入值的样本标准偏差。 $sum 返回数值的总和。忽略非数字值。 $group运算符和内存该$group阶段的RAM限制为100兆字节。默认情况下，如果阶段超出此限制，$group将产生错误。但是，要允许处理大型数据集，请将allowDiskUse选项设置 true为启用$group操作以写入临时文件。有关详细信息，请参阅db.collection.aggregate()方法和 aggregate命令。 版本2.6中更改： MongoDB为$group舞台引入了100兆字节的RAM限制， 以及allowDiskUse处理大型数据集操作的选项。 示例1.计算计数，总和和平均值给出sales包含以下文档的集合： 12345&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;abc&quot;, &quot;price&quot; : 10, &quot;quantity&quot; : 2, &quot;date&quot; : ISODate(&quot;2014-03-01T08:00:00Z&quot;) &#125;&#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;jkl&quot;, &quot;price&quot; : 20, &quot;quantity&quot; : 1, &quot;date&quot; : ISODate(&quot;2014-03-01T09:00:00Z&quot;) &#125;&#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;xyz&quot;, &quot;price&quot; : 5, &quot;quantity&quot; : 10, &quot;date&quot; : ISODate(&quot;2014-03-15T09:00:00Z&quot;) &#125;&#123; &quot;_id&quot; : 4, &quot;item&quot; : &quot;xyz&quot;, &quot;price&quot; : 5, &quot;quantity&quot; : 20, &quot;date&quot; : ISODate(&quot;2014-04-04T11:21:39.736Z&quot;) &#125;&#123; &quot;_id&quot; : 5, &quot;item&quot; : &quot;abc&quot;, &quot;price&quot; : 10, &quot;quantity&quot; : 10, &quot;date&quot; : ISODate(&quot;2014-04-04T21:23:13.331Z&quot;) &#125; 按月，日和年分组以下聚合操作使用$group阶段按月，日和年对文档进行分组，并计算总价格和平均数量，并计算每个组的文档： 123456789101112131415161718db.sales.aggregate( [ &#123; $group : &#123; _id : &#123; month: &#123; $month: &quot;$date&quot; &#125;, day: &#123; $dayOfMonth: &quot;$date&quot; &#125;, year: &#123; $year: &quot;$date&quot; &#125; &#125;, totalPrice: &#123; $sum: &#123; $multiply: [ &quot;$price&quot;, &quot;$quantity&quot; ] &#125; &#125;, averageQuantity: &#123; $avg: &quot;$quantity&quot; &#125;, count: &#123; $sum: 1 &#125; &#125; &#125; ])&#123; &quot;_id&quot; : &#123; &quot;month&quot; : 3, &quot;day&quot; : 15, &quot;year&quot; : 2014 &#125;, &quot;totalPrice&quot; : 50, &quot;averageQuantity&quot; : 10, &quot;count&quot; : 1 &#125;&#123; &quot;_id&quot; : &#123; &quot;month&quot; : 4, &quot;day&quot; : 4, &quot;year&quot; : 2014 &#125;, &quot;totalPrice&quot; : 200, &quot;averageQuantity&quot; : 15, &quot;count&quot; : 2 &#125;&#123; &quot;_id&quot; : &#123; &quot;month&quot; : 3, &quot;day&quot; : 1, &quot;year&quot; : 2014 &#125;, &quot;totalPrice&quot; : 40, &quot;averageQuantity&quot; : 1.5, &quot;count&quot; : 2 &#125; 2.分组null下面的聚合操作指定一组_id的 null，计算总价格和平均数量以及计数集合中的所有文件： 123456789101112131415db.sales.aggregate( [ &#123; $group : &#123; _id : null, totalPrice: &#123; $sum: &#123; $multiply: [ &quot;$price&quot;, &quot;$quantity&quot; ] &#125; &#125;, averageQuantity: &#123; $avg: &quot;$quantity&quot; &#125;, count: &#123; $sum: 1 &#125; &#125; &#125; ])// result&#123; &quot;_id&quot; : null, &quot;totalPrice&quot; : 290, &quot;averageQuantity&quot; : 8.6, &quot;count&quot; : 5 &#125; 也可以看看 $count 3.检索不同的值给出sales包含以下文档的集合： 123456789101112131415&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;abc&quot;, &quot;price&quot; : 10, &quot;quantity&quot; : 2, &quot;date&quot; : ISODate(&quot;2014-03-01T08:00:00Z&quot;) &#125;&#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;jkl&quot;, &quot;price&quot; : 20, &quot;quantity&quot; : 1, &quot;date&quot; : ISODate(&quot;2014-03-01T09:00:00Z&quot;) &#125;&#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;xyz&quot;, &quot;price&quot; : 5, &quot;quantity&quot; : 10, &quot;date&quot; : ISODate(&quot;2014-03-15T09:00:00Z&quot;) &#125;&#123; &quot;_id&quot; : 4, &quot;item&quot; : &quot;xyz&quot;, &quot;price&quot; : 5, &quot;quantity&quot; : 20, &quot;date&quot; : ISODate(&quot;2014-04-04T11:21:39.736Z&quot;) &#125;&#123; &quot;_id&quot; : 5, &quot;item&quot; : &quot;abc&quot;, &quot;price&quot; : 10, &quot;quantity&quot; : 10, &quot;date&quot; : ISODate(&quot;2014-04-04T21:23:13.331Z&quot;) &#125;以下聚合操作使用该$group阶段按项目对文档进行分组以检索不同的项目值：db.sales.aggregate( [ &#123; $group : &#123; _id : &quot;$item&quot; &#125; &#125; ] )// result&#123; &quot;_id&quot; : &quot;xyz&quot; &#125;&#123; &quot;_id&quot; : &quot;jkl&quot; &#125;&#123; &quot;_id&quot; : &quot;abc&quot; &#125; 4.Pivot Data12345678910111213141516&#123; &quot;_id&quot; : 8751, &quot;title&quot; : &quot;The Banquet&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 2 &#125;&#123; &quot;_id&quot; : 8752, &quot;title&quot; : &quot;Divine Comedy&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 1 &#125;&#123; &quot;_id&quot; : 8645, &quot;title&quot; : &quot;Eclogues&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 2 &#125;&#123; &quot;_id&quot; : 7000, &quot;title&quot; : &quot;The Odyssey&quot;, &quot;author&quot; : &quot;Homer&quot;, &quot;copies&quot; : 10 &#125;&#123; &quot;_id&quot; : 7020, &quot;title&quot; : &quot;Iliad&quot;, &quot;author&quot; : &quot;Homer&quot;, &quot;copies&quot; : 10 &#125;以下聚合操作将books 集合中的数据转化为具有按作者分组的标题db.books.aggregate( [ &#123; $group : &#123; _id : &quot;$author&quot;, books: &#123; $push: &quot;$title&quot; &#125; &#125; &#125; ])该操作返回以下文档：&#123; &quot;_id&quot; : &quot;Homer&quot;, &quot;books&quot; : [ &quot;The Odyssey&quot;, &quot;Iliad&quot; ] &#125;&#123; &quot;_id&quot; : &quot;Dante&quot;, &quot;books&quot; : [ &quot;The Banquet&quot;, &quot;Divine Comedy&quot;, &quot;Eclogues&quot; ] &#125; 分组文件author以下聚合操作使用$$ROOT 系统变量按作者对文档进行分组。生成的文件不得超过限制。 BSON Document Size:最大BSON文档大小为16兆字节。 最大文档大小有助于确保单个文档不会使用过多的RAM，或者在传输过程中使用过多的带宽。为了存储大于最大大小的文档，MongoDB提供了GridFS API。有关GridFS的更多信息，请参阅驱动程序mongofiles的文档。 1234567891011121314151617181920212223242526db.books.aggregate( [ &#123; $group : &#123; _id : &quot;$author&quot;, books: &#123; $push: &quot;$$ROOT&quot; &#125; &#125; &#125; ])result&#123; &quot;_id&quot; : &quot;Homer&quot;, &quot;books&quot; : [ &#123; &quot;_id&quot; : 7000, &quot;title&quot; : &quot;The Odyssey&quot;, &quot;author&quot; : &quot;Homer&quot;, &quot;copies&quot; : 10 &#125;, &#123; &quot;_id&quot; : 7020, &quot;title&quot; : &quot;Iliad&quot;, &quot;author&quot; : &quot;Homer&quot;, &quot;copies&quot; : 10 &#125; ]&#125;&#123; &quot;_id&quot; : &quot;Dante&quot;, &quot;books&quot; : [ &#123; &quot;_id&quot; : 8751, &quot;title&quot; : &quot;The Banquet&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 2 &#125;, &#123; &quot;_id&quot; : 8752, &quot;title&quot; : &quot;Divine Comedy&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 1 &#125;, &#123; &quot;_id&quot; : 8645, &quot;title&quot; : &quot;Eclogues&quot;, &quot;author&quot; : &quot;Dante&quot;, &quot;copies&quot; : 2 &#125; ]&#125; $unwind（统计数组的每一个值，输出以该值为维度的数据，数据变多了，其他值一样） 从输入文档解构数组字段以输出每个元素的文档。每个输出文档都是输入文档，其中数组字段的值由元素替换。 该$unwind阶段具有以下两种语法之一： 操作数是一个字段路径：要指定字段路径，请在字段名称前加上美元符号， $并用引号括起来 1&#123; $unwind: &lt;field path&gt; &#125; 操作数是一个文件： 12345678&#123; $unwind: &#123; path: &lt;field path&gt;, includeArrayIndex: &lt;string&gt;, preserveNullAndEmptyArrays: &lt;boolean&gt; &#125;&#125; 领域 类型 描述 path string 数组字段的字段路径。要指定字段路径，请在字段名称前加上美元符号，$并用引号括起来。 includeArrayIndex string 可选的。用于保存元素的数组索引的新字段的名称。该名称不能以美元符号开头$。 preserveNullAndEmptyArrays boolean 可选的。如果true，如果path为null，缺少或为空数组，则$unwind输出文档。如果false，$unwind如果path为null，缺少或空数组， 则不输出文档。默认值为false。 行为非阵列场路径版本3.2中更改：$unwind非数组操作数上的阶段不再出错。如果操作数未解析为数组但未丢失，null或空数组，$unwind则将操作数视为单个元素数组。 以前，如果字段路径指定的字段中的值 不是数组，db.collection.aggregate()则会生成错误。 缺少字段如果为输入文档中不存在的字段指定路径，或者该字段为空数组，则$unwind默认情况下会忽略输入文档，并且不会输出该输入文档的文档。 版本3.2中的新增功能：要输出缺少数组字段的文档，null或空数组，请使用该选项preserveNullAndEmptyArrays。 示例展开数组考虑inventory使用以下文档： 123456789101112&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC1&quot;, sizes: [ &quot;S&quot;, &quot;M&quot;, &quot;L&quot;] &#125;以下聚合使用该$unwind阶段为sizes数组中的每个元素输出文档：db.inventory.aggregate( [ &#123; $unwind : &quot;$sizes&quot; &#125; ] )该操作返回以下结果：每个文档都与输入文档相同，除了sizes现在包含原始sizes数组值的字段的值 。&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC1&quot;, &quot;sizes&quot; : &quot;S&quot; &#125;&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC1&quot;, &quot;sizes&quot; : &quot;M&quot; &#125;&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC1&quot;, &quot;sizes&quot; : &quot;L&quot; &#125; includeArrayIndex和preserveNullAndEmptyArrays¶版本3.2中的新功能。 集合inventory包含以下文件： 1234567891011121314151617&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC&quot;, &quot;sizes&quot;: [ &quot;S&quot;, &quot;M&quot;, &quot;L&quot;] &#125;&#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;EFG&quot;, &quot;sizes&quot; : [ ] &#125;&#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;IJK&quot;, &quot;sizes&quot;: &quot;M&quot; &#125;&#123; &quot;_id&quot; : 4, &quot;item&quot; : &quot;LMN&quot; &#125;&#123; &quot;_id&quot; : 5, &quot;item&quot; : &quot;XYZ&quot;, &quot;sizes&quot; : null &#125;以下$unwind操作是等效的，并返回sizes字段中每个元素的文档。如果sizes 字段未解析为数组但未丢失，null或空数组，$unwind则将非数组操作数视为单个元素数组。db.inventory.aggregate( [ &#123; $unwind: &quot;$sizes&quot; &#125; ] )db.inventory.aggregate( [ &#123; $unwind: &#123; path: &quot;$sizes&quot; &#125; &#125; ] )该操作返回以下文档：&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC&quot;, &quot;sizes&quot; : &quot;S&quot; &#125;&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC&quot;, &quot;sizes&quot; : &quot;M&quot; &#125;&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC&quot;, &quot;sizes&quot; : &quot;L&quot; &#125;&#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;IJK&quot;, &quot;sizes&quot; : &quot;M&quot; &#125; 以下$unwind操作使用该 includeArrayIndex选项输出数组元素的数组索引。123456789db.inventory.aggregate( [ &#123; $unwind: &#123; path: &quot;$sizes&quot;, includeArrayIndex: &quot;arrayIndex&quot; &#125; &#125; ] )该操作展开sizes数组并在新arrayIndex字段中包含数组索引的数组索引。如果该sizes 字段未解析为数组但未丢失，null或空数组，则该arrayIndex字段为null。&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC&quot;, &quot;sizes&quot; : &quot;S&quot;, &quot;arrayIndex&quot; : NumberLong(0) &#125;&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC&quot;, &quot;sizes&quot; : &quot;M&quot;, &quot;arrayIndex&quot; : NumberLong(1) &#125;&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC&quot;, &quot;sizes&quot; : &quot;L&quot;, &quot;arrayIndex&quot; : NumberLong(2) &#125;&#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;IJK&quot;, &quot;sizes&quot; : &quot;M&quot;, &quot;arrayIndex&quot; : null &#125; 以下$unwind操作使用该 preserveNullAndEmptyArrays选项在输出中包含sizes缺少字段的文档，null或空数组。12345678910111213db.inventory.aggregate( [ &#123; $unwind: &#123; path: &quot;$sizes&quot;, preserveNullAndEmptyArrays: true &#125; &#125;] )除了展开sizes元素数组或非空非数组字段的文档之外，操作还会输出sizes缺少字段的空文件或空数组，而不进行修改：&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC&quot;, &quot;sizes&quot; : &quot;S&quot; &#125;&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC&quot;, &quot;sizes&quot; : &quot;M&quot; &#125;&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC&quot;, &quot;sizes&quot; : &quot;L&quot; &#125;&#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;EFG&quot; &#125;&#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;IJK&quot;, &quot;sizes&quot; : &quot;M&quot; &#125;&#123; &quot;_id&quot; : 4, &quot;item&quot; : &quot;LMN&quot; &#125;&#123; &quot;_id&quot; : 5, &quot;item&quot; : &quot;XYZ&quot;, &quot;sizes&quot; : null &#125; $match 过滤文档以仅将符合指定条件的文档传递到下一个管道阶段。 该$match阶段具有以下原型形式： 1&#123; $match: &#123; &lt;query&gt; &#125; &#125; $match获取指定查询条件的文档。查询语法与读操作查询语法相同; 即 $match不接受原始聚合表达式。相反，使用$expr查询表达式包含聚合表达式$match。 行为Pipeline Optimization 放置$match在聚集早 管道越好。由于$match限制了聚合管道中的文档总数，因此先前的$match操作可以最大限度地减少管道的处理量。 如果您$match在管道的最开头放置一个，则查询可以利用其他任何索引db.collection.find() 或索引db.collection.findOne()。 限制该$match查询语法等同于读出操作查询语法; 即 $match不接受原始聚合表达式。要包含聚合表达式$match，请使用$expr查询表达式： 1&#123; $match: &#123; $expr: &#123; &lt;aggregation expression&gt; &#125; &#125; &#125; 不能使用$where在$match查询作为聚合管道的一部分。 您不能在 查询中使用$near或作为聚合管道的一部分。作为替代方案，您可以：$nearSphere$match 使用$geoNear舞台而不是$match舞台。 使用$geoWithin查询运营商，$center或 $centerSphere在$match阶段。 要$text在$match舞台上使用， $match舞台必须是管道的第一阶段。 视图不支持文本搜索。 示例平等匹配这些示例使用以articles下列文档命名的集合： 1234567891011121314151617181920&#123; &quot;_id&quot; : ObjectId(&quot;512bc95fe835e68f199c8686&quot;), &quot;author&quot; : &quot;dave&quot;, &quot;score&quot; : 80, &quot;views&quot; : 100 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;512bc962e835e68f199c8687&quot;), &quot;author&quot; : &quot;dave&quot;, &quot;score&quot; : 85, &quot;views&quot; : 521 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;55f5a192d4bede9ac365b257&quot;), &quot;author&quot; : &quot;ahn&quot;, &quot;score&quot; : 60, &quot;views&quot; : 1000 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;55f5a192d4bede9ac365b258&quot;), &quot;author&quot; : &quot;li&quot;, &quot;score&quot; : 55, &quot;views&quot; : 5000 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;55f5a1d3d4bede9ac365b259&quot;), &quot;author&quot; : &quot;annT&quot;, &quot;score&quot; : 60, &quot;views&quot; : 50 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;55f5a1d3d4bede9ac365b25a&quot;), &quot;author&quot; : &quot;li&quot;, &quot;score&quot; : 94, &quot;views&quot; : 999 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;55f5a1d3d4bede9ac365b25b&quot;), &quot;author&quot; : &quot;ty&quot;, &quot;score&quot; : 95, &quot;views&quot; : 1000 &#125;平等匹配以下操作用于$match执行简单的相等匹配：db.articles.aggregate( [ &#123; $match : &#123; author : &quot;dave&quot; &#125; &#125; ]);将$match选择其中的文件author 字段等于dave，并聚集返回以下内容：&#123; &quot;_id&quot; : ObjectId(&quot;512bc95fe835e68f199c8686&quot;), &quot;author&quot; : &quot;dave&quot;, &quot;score&quot; : 80, &quot;views&quot; : 100 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;512bc962e835e68f199c8687&quot;), &quot;author&quot; : &quot;dave&quot;, &quot;score&quot; : 85, &quot;views&quot; : 521 &#125; 执行计数以下示例使用$match管道运算符选择要处理的文档 ，然后将结果通过$group管道传输给管道运算符以计算文档计数： 123456789db.articles.aggregate( [ &#123; $match: &#123; $or: [ &#123; score: &#123; $gt: 70, $lt: 90 &#125; &#125;, &#123; views: &#123; $gte: 1000 &#125; &#125; ] &#125; &#125;, &#123; $group: &#123; _id: null, count: &#123; $sum: 1 &#125; &#125; &#125;] );在凝集管道，$match选择的文件，其中任一score大于70和小于90 或views大于或等于1000。然后将这些文件用管道输送$group到进行计数。聚合返回以下内容：&#123; “ _ id” ： null ， “count” ： 5 &#125; $lookup版本3.2中的新功能。 对同一 数据库中的未整数集合执行左外连接，以从“已连接”集合中过滤文档以进行处理。对于每个输入文档，该$lookup阶段添加一个新的数组字段，其元素是来自“已连接”集合的匹配文档。该$lookup阶段通过这些重塑文件到下一阶段。 语法该$lookup阶段具有以下语法： 平等匹配要在输入文档中的字段与“已加入”集合的文档中的字段之间执行相等匹配，该 $lookup阶段具有以下语法： 123456789&#123; $lookup: &#123; from: &lt;collection to join&gt;, localField: &lt;field from the input documents&gt;, foreignField: &lt;field from the documents of the &quot;from&quot; collection&gt;, as: &lt;output array field&gt; &#125;&#125; 在$lookup需要具有以下字段的文档： 领域 描述 from 指定同一数据库中的集合以执行连接。该from集合无法分片。有关详细信息，请参阅Sharded Collection Restrictions。 localField 指定输入到$lookup舞台的文档中的字段 。$lookup执行上的平等匹配localField到foreignField从的文档from 集合。如果输入文档不包含该输入文档 localField，则$lookup将该字段视为具有null用于匹配目的的值。注意如果您localField是一个数组，则可能需要$unwind在管道中添加一个 阶段。否则，之间的平等条件localField，并 foreignField为。foreignField: { $in: [localField.elem1, localField.elem2, ... ] }请参阅此页面上的示例。 foreignField 指定from 集合中文档的字段。$lookup执行上的平等匹配foreignField到localField从输入文件。如果from集合中的文档不包含foreignField，$lookup则将值视为null匹配目的。 as 指定要添加到输入文档的新数组字段的名称。新数组字段包含from集合中的匹配文档。如果输入文档中已存在指定的名称，则会覆盖现有字段 。 该操作将对应于以下伪SQL语句： 12345SELECT *, &lt;output array field&gt;FROM collectionWHERE &lt;output array field&gt; IN (SELECT * FROM &lt;collection to join&gt; WHERE &lt;foreignField&gt;= &lt;collection.localField&gt;); 请参阅以下示例： 使用$ lookup执行单一等式连接 对数组使用$ lookup 对$ mergeObjects使用$ lookup 加入条件和不相关的子查询版本3.6中的新功能。 要在两个集合之间执行不相关的子查询以及允许除单个相等匹配之外的其他连接条件，该 $lookup阶段具有以下语法： 123456789&#123; $lookup: &#123; from: &lt;collection to join&gt;, let: &#123; &lt;var_1&gt;: &lt;expression&gt;, …, &lt;var_n&gt;: &lt;expression&gt; &#125;, pipeline: [ &lt;pipeline to execute on the collection to join&gt; ], as: &lt;output array field&gt; &#125;&#125; 在$lookup需要具有以下字段的文档： 领域 描述 from 指定同一数据库中的集合以执行连接。该from集合无法分片。有关详细信息，请参阅Sharded Collection Restrictions。 let 可选的。指定要在pipeline字段阶段中使用的变量。使用变量表达式从输入到$lookup舞台的文档中访问字段。在pipeline不能直接访问输入文档字段。相反，首先定义输入文档字段的变量，然后引用中的阶段中的变量pipeline。要访问中的let变量pipeline，请使用 $expr运算符。注意该let变量是在该阶段访问 pipeline，包括额外的$lookup嵌套的阶段pipeline。 pipeline 指定要在已连接集合上运行的管道。该 pipeline决定从加入集合生成的文件。要返回所有文档，请指定一个空管道 []。在pipeline不能直接访问输入文档字段。相反，首先定义输入文档字段的变量，然后引用中的阶段中的变量pipeline。要访问中的let变量pipeline，请使用 $expr运算符。注意该let变量是在该阶段访问 pipeline，包括额外的$lookup嵌套的阶段pipeline。 as 指定要添加到输入文档的新数组字段的名称。新数组字段包含from集合中的匹配文档。如果输入文档中已存在指定的名称，则会覆盖现有字段 。 该操作将对应于以下伪SQL语句： 12345SELECT *, &lt;output array field&gt;FROM collectionWHERE &lt;output array field&gt; IN (SELECT &lt;documents as determined from the pipeline&gt; FROM &lt;collection to join&gt; WHERE &lt;pipeline&gt; ); 请参阅以下示例： 使用$ lookup指定多个连接条件 不相关的子查询 考虑视图和整理如果执行涉及多个视图的聚合（例如使用$lookup或）$graphLookup，则视图必须具有相同的排序规则。 分片收集限制在$lookup阶段，from收集不能被 分片。但是，可以对运行该aggregate()方法的集合 进行分片。也就是说，在以下内容中： 123db.collection.aggregate([ &#123; $lookup: &#123; from: &quot;fromCollection&quot;, ... &#125; &#125;]) 该collection可以分片。 在fromCollection不能分片。 因此，要将分片集合与未分片集合连接，您可以在分片集合上运行聚合并查找未整理的集合; 例如： 123db.shardedCollection.aggregate([ &#123; $lookup: &#123; from: &quot;unshardedCollection&quot;, ... &#125; &#125;]) 或者，或者要连接多个分片集合，请考虑： 修改客户端应用程序以执行手动查找，而不是使用$lookup聚合阶段。 如果可能，使用嵌入式数据模型，无需加入集合。 示例执行单个等式连接$lookuporders使用以下文档创建集合： 12345db.orders.insert([ &#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;almonds&quot;, &quot;price&quot; : 12, &quot;quantity&quot; : 2 &#125;, &#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;pecans&quot;, &quot;price&quot; : 20, &quot;quantity&quot; : 1 &#125;, &#123; &quot;_id&quot; : 3 &#125;]) inventory使用以下文档创建另一个集合： 12345678db.inventory.insert([ &#123; &quot;_id&quot; : 1, &quot;sku&quot; : &quot;almonds&quot;, description: &quot;product 1&quot;, &quot;instock&quot; : 120 &#125;, &#123; &quot;_id&quot; : 2, &quot;sku&quot; : &quot;bread&quot;, description: &quot;product 2&quot;, &quot;instock&quot; : 80 &#125;, &#123; &quot;_id&quot; : 3, &quot;sku&quot; : &quot;cashews&quot;, description: &quot;product 3&quot;, &quot;instock&quot; : 60 &#125;, &#123; &quot;_id&quot; : 4, &quot;sku&quot; : &quot;pecans&quot;, description: &quot;product 4&quot;, &quot;instock&quot; : 70 &#125;, &#123; &quot;_id&quot; : 5, &quot;sku&quot;: null, description: &quot;Incomplete&quot; &#125;, &#123; &quot;_id&quot; : 6 &#125;]) 在下面的聚合操作orders系列外，从文件orders从文件 inventory使用的字段集合item从 orders收集和sku从外地inventory 收集： 123456789101112131415161718192021222324252627282930313233343536373839db.orders.aggregate([ &#123; $lookup: &#123; from: &quot;inventory&quot;, localField: &quot;item&quot;, foreignField: &quot;sku&quot;, as: &quot;inventory_docs&quot; &#125; &#125;])该操作返回以下文档：&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;almonds&quot;, &quot;price&quot; : 12, &quot;quantity&quot; : 2, &quot;inventory_docs&quot; : [ &#123; &quot;_id&quot; : 1, &quot;sku&quot; : &quot;almonds&quot;, &quot;description&quot; : &quot;product 1&quot;, &quot;instock&quot; : 120 &#125; ]&#125;&#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;pecans&quot;, &quot;price&quot; : 20, &quot;quantity&quot; : 1, &quot;inventory_docs&quot; : [ &#123; &quot;_id&quot; : 4, &quot;sku&quot; : &quot;pecans&quot;, &quot;description&quot; : &quot;product 4&quot;, &quot;instock&quot; : 70 &#125; ]&#125;&#123; &quot;_id&quot; : 3, &quot;inventory_docs&quot; : [ &#123; &quot;_id&quot; : 5, &quot;sku&quot; : null, &quot;description&quot; : &quot;Incomplete&quot; &#125;, &#123; &quot;_id&quot; : 6 &#125; ]&#125; 该操作将对应于以下伪SQL语句： 12345SELECT *, inventory_docsFROM ordersWHERE inventory_docs IN (SELECT *FROM inventoryWHERE sku= orders.item); 使用$lookup与数组如果您localField是一个数组，并且您希望将其中的元素与foreignField单个元素进行匹配，则您需要$unwind将该数组作为聚合管道的一个阶段。 考虑一个orders包含以下文档的集合： 12&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;MON1003&quot;, &quot;price&quot; : 350, &quot;quantity&quot; : 2, &quot;specs&quot; :[ &quot;27 inch&quot;, &quot;Retina display&quot;, &quot;1920x1080&quot; ], &quot;type&quot; : &quot;Monitor&quot; &#125; 另一个集合inventory包含以下文档： 123456&#123; &quot;_id&quot; : 1, &quot;sku&quot; : &quot;MON1003&quot;, &quot;type&quot; : &quot;Monitor&quot;, &quot;instock&quot; : 120,&quot;size&quot; : &quot;27 inch&quot;, &quot;resolution&quot; : &quot;1920x1080&quot; &#125;&#123; &quot;_id&quot; : 2, &quot;sku&quot; : &quot;MON1012&quot;, &quot;type&quot; : &quot;Monitor&quot;, &quot;instock&quot; : 85,&quot;size&quot; : &quot;23 inch&quot;, &quot;resolution&quot; : &quot;1280x800&quot; &#125;&#123; &quot;_id&quot; : 3, &quot;sku&quot; : &quot;MON1031&quot;, &quot;type&quot; : &quot;Monitor&quot;, &quot;instock&quot; : 60,&quot;size&quot; : &quot;23 inch&quot;, &quot;display_type&quot; : &quot;LED&quot; &#125; 以下聚合操作对orders集合中的文档执行连接，这些文档 将specs 数组的特定元素size与inventory集合中的字段进行匹配。 1234567891011121314151617181920212223242526272829303132333435363738db.orders.aggregate([ &#123; $unwind: &quot;$specs&quot; &#125;, &#123; $lookup: &#123; from: &quot;inventory&quot;, localField: &quot;specs&quot;, foreignField: &quot;size&quot;, as: &quot;inventory_docs&quot; &#125; &#125;, &#123; $match: &#123; &quot;inventory_docs&quot;: &#123; $ne: [] &#125; &#125; &#125;])该操作返回以下文档：&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;MON1003&quot;, &quot;price&quot; : 350, &quot;quantity&quot; : 2, &quot;specs&quot; : &quot;27 inch&quot;, &quot;type&quot; : &quot;Monitor&quot;, &quot;inventory_docs&quot; : [ &#123; &quot;_id&quot; : 1, &quot;sku&quot; : &quot;MON1003&quot;, &quot;type&quot; : &quot;Monitor&quot;, &quot;instock&quot; : 120, &quot;size&quot; : &quot;27 inch&quot;, &quot;resolution&quot; : &quot;1920x1080&quot; &#125; ]&#125; 使用$lookup与$mergeObjects在版本3.6中更改： MongoDB 3.6添加了$mergeObjects运算符以将多个文档合并到单个文档中 orders使用以下文档创建集合： 1234567891011db.orders.insert([ &#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;almonds&quot;, &quot;price&quot; : 12, &quot;quantity&quot; : 2 &#125;, &#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;pecans&quot;, &quot;price&quot; : 20, &quot;quantity&quot; : 1 &#125;])db.items.insert([ &#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;almonds&quot;, description: &quot;almond clusters&quot;, &quot;instock&quot; : 120 &#125;, &#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;bread&quot;, description: &quot;raisin and nut bread&quot;, &quot;instock&quot; : 80 &#125;, &#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;pecans&quot;, description: &quot;candied pecans&quot;, &quot;instock&quot; : 60 &#125;]) 下面的操作首先使用$lookup阶段加入由两个集合item的字段，然后使用 $mergeObjects在$replaceRoot给加盟的文件从合并items和orders： 123456789101112131415161718db.orders.aggregate([ &#123; $lookup: &#123; from: &quot;items&quot;, localField: &quot;item&quot;, // field in the orders collection foreignField: &quot;item&quot;, // field in the items collection as: &quot;fromItems&quot; &#125; &#125;, &#123; $replaceRoot: &#123; newRoot: &#123; $mergeObjects: [ &#123; $arrayElemAt: [ &quot;$fromItems&quot;, 0 ] &#125;, &quot;$$ROOT&quot; ] &#125; &#125; &#125;, &#123; $project: &#123; fromItems: 0 &#125; &#125;])该操作返回以下文档：&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;almonds&quot;, &quot;description&quot; : &quot;almond clusters&quot;, &quot;instock&quot; : 120, &quot;price&quot; : 12, &quot;quantity&quot; : 2 &#125;&#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;pecans&quot;, &quot;description&quot; : &quot;candied pecans&quot;, &quot;instock&quot; : 60, &quot;price&quot; : 20, &quot;quantity&quot; : 1 &#125; 使用指定多个连接条件$lookup在版本3.6中更改： MongoDB 3.6添加了对在已加入集合上执行管道的支持，这允许指定多个连接条件以及不相关的子查询。 1234567891011121314db.orders.insert([ &#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;almonds&quot;, &quot;price&quot; : 12, &quot;ordered&quot; : 2 &#125;, &#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;pecans&quot;, &quot;price&quot; : 20, &quot;ordered&quot; : 1 &#125;, &#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;cookies&quot;, &quot;price&quot; : 10, &quot;ordered&quot; : 60 &#125;])db.warehouses.insert([ &#123; &quot;_id&quot; : 1, &quot;stock_item&quot; : &quot;almonds&quot;, warehouse: &quot;A&quot;, &quot;instock&quot; : 120 &#125;, &#123; &quot;_id&quot; : 2, &quot;stock_item&quot; : &quot;pecans&quot;, warehouse: &quot;A&quot;, &quot;instock&quot; : 80 &#125;, &#123; &quot;_id&quot; : 3, &quot;stock_item&quot; : &quot;almonds&quot;, warehouse: &quot;B&quot;, &quot;instock&quot; : 60 &#125;, &#123; &quot;_id&quot; : 4, &quot;stock_item&quot; : &quot;cookies&quot;, warehouse: &quot;B&quot;, &quot;instock&quot; : 40 &#125;, &#123; &quot;_id&quot; : 5, &quot;stock_item&quot; : &quot;cookies&quot;, warehouse: &quot;A&quot;, &quot;instock&quot; : 80 &#125;]) 以下操作将orders集合与 warehouse项目集合以及库存中的数量是否足以覆盖订购数量： 1234567891011121314151617181920212223242526272829303132db.orders.aggregate([ &#123; $lookup: &#123; from: &quot;warehouses&quot;, let: &#123; order_item: &quot;$item&quot;, order_qty: &quot;$ordered&quot; &#125;, pipeline: [ &#123; $match: &#123; $expr: &#123; $and: [ &#123; $eq: [ &quot;$stock_item&quot;, &quot;$$order_item&quot; ] &#125;, &#123; $gte: [ &quot;$instock&quot;, &quot;$$order_qty&quot; ] &#125; ] &#125; &#125; &#125;, &#123; $project: &#123; stock_item: 0, _id: 0 &#125; &#125; ], as: &quot;stockdata&quot; &#125; &#125;])该操作返回以下文档：&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;almonds&quot;, &quot;price&quot; : 12, &quot;ordered&quot; : 2, &quot;stockdata&quot; : [ &#123; &quot;warehouse&quot; : &quot;A&quot;, &quot;instock&quot; : 120 &#125;, &#123; &quot;warehouse&quot; : &quot;B&quot;, &quot;instock&quot; : 60 &#125; ] &#125;&#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;pecans&quot;, &quot;price&quot; : 20, &quot;ordered&quot; : 1, &quot;stockdata&quot; : [ &#123; &quot;warehouse&quot; : &quot;A&quot;, &quot;instock&quot; : 80 &#125; ] &#125;&#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;cookies&quot;, &quot;price&quot; : 10, &quot;ordered&quot; : 60, &quot;stockdata&quot; : [ &#123; &quot;warehouse&quot; : &quot;A&quot;, &quot;instock&quot; : 80 &#125; ] &#125; 该操作将对应于以下伪SQL语句： 123456SELECT *, stockdataFROM ordersWHERE stockdata IN (SELECT warehouse, instock FROM warehouses WHERE stock_item= orders.item AND instock &gt;= orders.ordered ); 不相关的子查询在版本3.6中更改： MongoDB 3.6添加了对在已加入集合上执行管道的支持，这允许指定多个连接条件以及不相关的子查询。 absences使用以下文档创建集合： 12345678910111213db.absences.insert([ &#123; &quot;_id&quot; : 1, &quot;student&quot; : &quot;Ann Aardvark&quot;, sickdays: [ new Date (&quot;2018-05-01&quot;),new Date (&quot;2018-08-23&quot;) ] &#125;, &#123; &quot;_id&quot; : 2, &quot;student&quot; : &quot;Zoe Zebra&quot;, sickdays: [ new Date (&quot;2018-02-01&quot;),new Date (&quot;2018-05-23&quot;) ] &#125;,])db.holidays.insert([ &#123; &quot;_id&quot; : 1, year: 2018, name: &quot;New Years&quot;, date: new Date(&quot;2018-01-01&quot;) &#125;, &#123; &quot;_id&quot; : 2, year: 2018, name: &quot;Pi Day&quot;, date: new Date(&quot;2018-03-14&quot;) &#125;, &#123; &quot;_id&quot; : 3, year: 2018, name: &quot;Ice Cream Day&quot;, date: new Date(&quot;2018-07-15&quot;) &#125;, &#123; &quot;_id&quot; : 4, year: 2017, name: &quot;New Years&quot;, date: new Date(&quot;2017-01-01&quot;) &#125;, &#123; &quot;_id&quot; : 5, year: 2017, name: &quot;Ice Cream Day&quot;, date: new Date(&quot;2017-07-16&quot;) &#125;]) 以下操作将absences集合与集合中的2018个假日信息结合在一起holidays： 12345678910111213141516171819202122db.absences.aggregate([ &#123; $lookup: &#123; from: &quot;holidays&quot;, pipeline: [ &#123; $match: &#123; year: 2018 &#125; &#125;, &#123; $project: &#123; _id: 0, date: &#123; name: &quot;$name&quot;, date: &quot;$date&quot; &#125; &#125; &#125;, &#123; $replaceRoot: &#123; newRoot: &quot;$date&quot; &#125; &#125; ], as: &quot;holidays&quot; &#125; &#125;])该操作返回以下内容：&#123; &quot;_id&quot; : 1, &quot;student&quot; : &quot;Ann Aardvark&quot;, &quot;sickdays&quot; : [ ISODate(&quot;2018-05-01T00:00:00Z&quot;), ISODate(&quot;2018-08-23T00:00:00Z&quot;) ], &quot;holidays&quot; : [ &#123; &quot;name&quot; : &quot;New Years&quot;, &quot;date&quot; : ISODate(&quot;2018-01-01T00:00:00Z&quot;) &#125;, &#123; &quot;name&quot; : &quot;Pi Day&quot;, &quot;date&quot; : ISODate(&quot;2018-03-14T00:00:00Z&quot;) &#125;, &#123; &quot;name&quot; : &quot;Ice Cream Day&quot;, &quot;date&quot; : ISODate(&quot;2018-07-15T00:00:00Z&quot;) &#125; ] &#125;&#123; &quot;_id&quot; : 2, &quot;student&quot; : &quot;Zoe Zebra&quot;, &quot;sickdays&quot; : [ ISODate(&quot;2018-02-01T00:00:00Z&quot;), ISODate(&quot;2018-05-23T00:00:00Z&quot;) ], &quot;holidays&quot; : [ &#123; &quot;name&quot; : &quot;New Years&quot;, &quot;date&quot; : ISODate(&quot;2018-01-01T00:00:00Z&quot;) &#125;, &#123; &quot;name&quot; : &quot;Pi Day&quot;, &quot;date&quot; : ISODate(&quot;2018-03-14T00:00:00Z&quot;) &#125;, &#123; &quot;name&quot; : &quot;Ice Cream Day&quot;, &quot;date&quot; : ISODate(&quot;2018-07-15T00:00:00Z&quot;) &#125; ] &#125; 该操作将对应于以下伪SQL语句： 12345SELECT *, holidaysFROM absencesWHERE holidays IN (SELECT name, date FROM holidays WHERE year = 2018); 参考文档 mongodb文档]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>aggregate</tag>
      </tags>
  </entry>
</search>
